%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      CoSTAR                       %
%   Continuation of Solution Torus AppRoximations   %
%                                                   %
%                    Tutorial:                      %
%            Quasi-Periodic Solutions               %
%               - Shooting Method -                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%           Welcome to the CoSTAR Tutorials!        %
%
% The tutorials comprehensively explain certain CoSTAR modules, which is why they are the perfect starting point for CoSTAR beginners.
% They are highly recommended if you are not yet familiar with the CoSTAR toolbox. 
% 
% If you have already used CoSTAR, you may find the CoSTAR examples helpful.
% These provide example code to briefly show how the toolbox can be set up and how a certain CoSTAR module can be used.
% There is a corresponding example for each tutorial and the code of both of them is identical.
%
% In this tutorial, we will look at how to compute quasi-periodic solutions using the quasi-periodic Shooting Method (SHM) to approximate ...           
% the solution (associated example: Example_QPS_SHM). We will learn how to set up CoSTAR and how to correctly define all the required ...
% settings on the basis of two different examples:
%
%  1. Continuation of the Duffing oscillator with double external forcing (full non-autonomous system)
%       1.1 Introduction
%       1.2 Continuation of excitation frequency
%           1.2.1 Setting useful variables
%           1.2.2 The CoSTAR settings
%           1.2.3 Calling CoSTAR and running the simulation
%       1.3 Postprocessing: Plot of hyper-time surfaces Z(theta1,theta2,mu)
%       1.4 Change of continuation parameter from excitation frequency to coefficient of nonlinear stiffness
%       ->  FDM specific: - Usage of the "options.opt_init"-fields:
%                               * 'ic', 'tinit', 'deltat' and 'dt' in section 1.2
%                               * 'iv' in section 1.4
%                         - Usage of the "options.opt_approx_method"-fields 'solver' and 'n_char' (in sections 1.2 and 1.4)
%
%  2. Continuation of Jeffcott(-Laval) rotor (mixed / half-autonomous system)
%       2.1 Introduction
%       2.2 Continuation of rotational speed
%           2.2.1 Setting useful variables
%           2.2.2 The CoSTAR settings
%           2.2.3 Calling CoSTAR and running the simulation
%       2.3 Postprocessing: Plot of hyper-time surfaces Z(theta1,theta2,mu)
%       ->  FDM specific: - Usage of the "options.opt_init"-fields 'ic', 'tinit', 'deltat' and 'dt'
%                         - Usage of the "options.opt_approx_method"-fields 'solver' and 'n_char'
%
%  3. Continuation of two coupled van der Pol oscillators (full autonomous system)
%       3.1 Introduction
%       3.2 Continuation of nonlinear damping
%           3.2.1 Setting useful variables
%           3.2.2 The CoSTAR settings
%           3.2.3 Calling CoSTAR and running the simulation
%       3.3 Postprocessing: Plot of hyper-time surfaces Z(theta1,theta2,mu)
%       ->  FDM specific: - Usage of the "options.opt_init"-fields 'ic', 'tinit', 'deltat' and 'dt'
%                         - Usage of the "options.opt_approx_method"-fields 'solver' and 'n_char'
%
% NOTE: All examples can be worked through independently.
%
% IMPORTANT: Explanations can be found at the beginning of new lines as well as right next to code, so make sure that you do not ...
%            miss some helpful comments!
%            Furthermore, it is advised to execute the code line by line or in blocks when going through this tutorial and do not ...
%            execute the complete script by clicking "Run" or pressing "F5". To do that, you can select the desired lines of code ...
%            to be executed and press "F9" or you can click right on the selected code and choose "Evaluate Selection in Command ...
%            Window". This should help to better understand what is going on and how CoSTAR works. 
%
% Alright, let's clean our "desk" and let's get started!
clear variables; clc; close all;                                        % clear workspace; clear command window; close all figures

% We need to add the main CoSTAR folder (and all subfolders) to MATLAB's search path. 
% Assuming you are running this script within the "Tutorials" subfolder of CoSTAR, this is done by:
% addpath(genpath('..\'))                                               % genpath() generates a search path containing all subfolders
% (The command is set as comment in order to prevent unwanted folders to be added to MATLAB's search path.)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%        Example No. 1: Duffing Oscillator        %%
%             Full Non-Autonomous System            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%               1.1  Introduction                   %
%
% The first example we have a look on features the Duffing equation with double external forcing. The dimensionless form of the ...
% equation reads:     x'' + 2*D*x' + x + kappa*x^3 = f1*sin(eta*tau) + f2*sin(ratio*eta*tau)     (1)
% where x is the deflection, D is the damping factor, kappa is the coefficient of the nonlinear stiffness, f1 and f2 are the 
% amplitudes of the excitation, eta is the dimensionless excitation frequency and tau is the dimensionless time. Following that, ...
% x' = dx/dtau and x'' = dx'/dtau holds. For a quasi-periodic solution to appear, the ratio of the excitation frequencies eta and ...
% ratio*eta must be irrational, which is ensured by the variable ratio.
% CoSTAR always needs the equation to be of the form dz/dt = f(t,z,param) (param represents all additional parameters), which is ...
% why we have to transform (1) into a system of two differential equations of first order. To do that, we introduce the state ...
% variable vector z = [z1; z2] = [x; x'], leading to:
% dz/dtau = f(tau,z,D,kappa,f1,f2,eta,ratio)  (2)  <=>  z1' = z2
%                                                       z2' = -2*D*z2 - z1 - kappa*z1^3 + f1*sin(eta*tau) + f2*sin(ratio*eta*tau)
%
% Our aim is to approximate the quasi-periodic solution of equation (2) z(tau) for eta in the range of [0.8, 2] using the SHM. ...
% Instead of the quasi-periodic solution itself, we calculate the (image of the) torus function Z = Z(theta_1,theta_2) that ...
% describes the torus on which the quasi-periodic solution evolves, using the hyper-time invariance equation:
% dZ/dtheta_1 * Omega_1 + dZ/dtheta_2 * Omega_2 = f(Z,theta_1,theta_2,param)   (3),
% where Omega_1 = eta and Omega_2 = ratio*eta are the excitation frequencies and where f is the right-hand side of (2). This ...
% problem can be rewritten into finding the zero set of the function g: R^(n+1) -> R^n with g = 0 and for eta in [0.8, 2], which ...
% defines a curve in (n+1)-dimensional space (n depends on the dimension of the system as well as the discretisation). Hence, a ...
% solution Z(theta_1,theta_2) is also denoted as a "point on the curve" in the following explanations. CoSTAR will approximate ...
% discrete points on this curve by executing a path continuation. As the frequency eta is varied, the continuation parameter is ...
% mu = eta. The remaining parameters are set to:
D = 0.05;            kappa = 1.5;
f1 = 0.25;           f2 = 0.25;
ratio = sqrt(2);


%     1.2 Continuation of excitation frequency      %
%
%          1.2.1 Setting useful variables           
%
% Before we specify the settings needed by CoSTAR, we introduce some important variables, which we will use later on. This is not ...
% necessarily needed but it helps to keep an overview of the most important variables/settings. Furthermore, important aspects of ...
% CoSTAR are explained here, making the following section "1.2.2 The CoSTAR settings" clearer.
mu_limit = [0.8, 2];                    % mu_limits = eta_limits = [0.8, 2] sets the upper and bottom limit of our continuation.
%
eta0 = mu_limit(1);                     % eta0 defines the eta-value at which the continuation begins.
%
Fcn =  @(t,z,param) duffing_ap_qp(t,z,param);   % Fcn is a function handle containing the right-hand side (RHS) of equation (2). 
% You may have noticed that Fcn is a function of t, z and param, whereas the right-hand side of (2) is a function of tau, z, ...
% D, kappa, f1, f2, eta and ratio. This is because CoSTAR ALWAYS requires the definition of Fcn as "Fcn = @(t,z,param) ..." when ...
% calculating quasi-periodic solutions. param is a cell array storing all parameters, apart from t and z, that need to be passed ...
% to (2). The time t as well as the state variable vector z are always treated separately and therefore not included in param. ...
% Here, we need to define param since we need to pass the parameters D, kappa, f1, f2, eta and ratio to Fcn. The name of the ...
% "time argument" being t (and not tau) is required by CoSTAR. It is equal to our dimensionless time tau.
%
% TASK: Open the function "duffing_ap_qp" (click the right mouse button right on it and choose 'Open "duffing_ap_qp"' or go into ...
%       the "RHS" subfolder located in the main path of CoSTAR and double click on the function). Have a look at how the equation ...
%       is defined and compare that to our system right next to equation (2).
% IMPORTANT: Please pay attention to how the state variables z1 and z2 are defined and how the parameters D, kappa, f1, f2, eta ...
%            and ratio are extracted from param. Moreover, pay attention to the definition and explanation of the time variables ...
%            t1 and t2, which is especially important when dealing with quasi-periodic solutions of forced systems.
%
% Now we define the "param" array. It is important that this is a cell array AND the order of the parameters placed in param must ...
% correspond to the definitions in the "duffing_ap_qp" function! For example, kappa is defined by kappa = param{2} in the ...
% "duffing_ap_qp" function. Therefore, kappa has to be the SECOND variable in the "param" array. For the variable eta, we use eta0 ...
% since the continuation starts at the eta-value of eta0.
param = {D, kappa, f1, f2, eta0, ratio};   
% Next, we have to tell CoSTAR where the continuation parameter is located within param. We also call this the "active parameter". ...
% This is done by defining an integer variable which is used to get the continuation parameter from param by cell indexing, i.e. ...
% continuation parameter mu = param{active_parameter}. As we want to continue the curve via eta and the corresponding value eta0 ...
% is the FIFTH element of param, we set:
active_parameter = 5;
%
% Going on, we need to set the non-autonomous frequency(s) of the external forcing (eta). This sounds a bit confusing since eta is ...
% the continuation parameter mu and we already set the range of the continuation by defining mu_limit. So why do we need to specify ...
% the non-autonomous frequency(s) again? The reason is that eta CAN be the continuation parameter but does NOT HAVE TO BE the ...
% continuation parameter. In order to deal with this uncertainty, we introduce a function handle which sets the non-autonomous ...
% frequency(s). In this case, there are two excitation frequencies, which are stored in an (1x2)-array: [eta, ratio*eta]. ...
% Substituting eta for the continuation parameter mu results in:
non_auto_freq = @(mu) [mu, ratio*mu];
% "non_auto_freq" ALWAYS have to be a function handle @(mu), even if it is not dependent on mu! For example, if we want to vary the ...
% damping factor D, the non-autonomous frequency(s) would have to be fixed, let us say eta = 1.5. In that case, we would have to ...
% define the function handle as non_auto_freq = @(mu) [1.5, ratio*1.5]. This rather unconventional approach not only keeps the code ...
% as compact as possible but also allows a great flexibility for the user since the non-autonomous frequency(s) can be an arbitrary ...
% function of mu (e.g. we can set non_auto_freq = @(mu) 10.*[mu, ratio*mu] etc.).
%
% Last but not least, we set variables which are used to create an initial value where the nonlinear system solver fsolve starts ...
% to find the first approximate solution of equation (3) at mu0 (i.e. the first point on the curve). Using the quasi-periodic ...
% shooting method, the initial value consists of n_char points that are distributed equidistantly on the manifold edge theta_1 = 0 ...
% (theta_2_i = i * DeltaTheta_2 for DeltaTheta_2 = 2*pi/n_char and i = 0, 1, 2, ... , n_char-1). Starting from these points, n_char ...
% characteristic curves (characteristics) are computed using time integration until the manifold edge at theta_1 = 2*pi is reached. ...
% These characteristics approximate the sought manifold Z(theta_1,theta_2,mu) if Z(0,theta_2,mu) = Z(2*pi,theta_2,mu) holds. The ...
% n_char points of the solution Z(theta_1,theta_2,mu) at (theta_1=0,theta_2_i) then form the method solution vector s, which is ...
% stored in the solution object S.
% The initial value for fsolve is generated based on a trajectory computed via time integration starting at an initial point called ...
% 'ic'. After an integration time of 'tinit', the trajectory is assumed to be close enough to the sought solution. Subsequently, ...
% another integration is started. In general, the trajectory of the latter integration does not fill the sought torus yet, but it ...
% is close enough to the manifold to generate the initial value for fsolve. Therefore, the initial value is extracted from this ...
% trajectory. For our Duffing example, we set the initial point ic to:
IC = [1; 1];


%            1.2.2 The CoSTAR settings              
%
% All information and settings which CoSTAR needs are defined in a structure array called "options". 
% The structure "options" itself consists of structure arrays that define important parameters used by different modules of CoSTAR.
% 
% CoSTAR ALWAYS needs the following "option" structures: "options.system", "options.opt_sol" and "options.opt_init".
% Depending on the system and problem, CoSTAR might need some or all of the following "option" structures additionally: 
% "options.opt_approx_method":  Required when calculating (quasi-) periodic solutions.
% "options.opt_cont":           Required when running a continuation.
% "options.opt_stability":      Optional when calculating the stability of solutions.
% In this case, all of the three additional "option" structures are needed.
% 
% Each of the "option" structures contain mandatory fields which ALWAYS have to be set. 
% Furthermore, there are optional fields that CAN be set. Most of the optional fields have a default value. 
% However, even optional fields NEED to be set in some cases (denoted as "Opt-Need.", e.g. 'param' in this example, see below).
% 
% IMPORTANT: All option structures must be created by the "costaropts" function. The syntax of the arguments of "costaropts" is ...
%            equivalent to the MATLAB struct function, i.e. costaropts(fieldname1,value1,...,fieldnameN,valueN).
%
% Let us start with the "options.system" structure:
options.system = costaropts('order',1,'dim',2,'rhs',Fcn,'param',param,'info','Continuation of Quasi-Periodic Duffing Equation');
% Mandatory fields: - 'order':  Describes the order of the ODE. As CoSTAR takes a system of differential equations of first order ...
%                               ( dz/dt = f(t,z,param) ), the order is 1.
%                   - 'dim':    Dimension of the state space. In this case, the dimension of the state variable vector z is 2.
%                   - 'rhs':    Right-hand side of equation (2), which we already assigned to the variable Fcn.                
% Opt-Need. field:  - 'param':  This field expects the previously defined "param" array. We NEED to set it because it is required ...
%                               by Fcn. Moreover, when executing a continuation, param is always necessary. However, param CAN be ...
%                               omitted when only calculating the initial solution (i.e. no continuation is carried out).
% Optional field:   - 'info':   Contains your individual text about the computation. This does not need to be set. However, it may ...
%                               help you later if you have forgotten what this computation is about (default: no text).
%
% Next, there is the "options.opt_sol" structure:
options.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','shooting','cont','on','stability','on', ...
                             'non_auto_freq',non_auto_freq,'act_param',active_parameter);
% Mandatory fields: - 'sol_type':       We need to specify what type of solution CoSTAR has to calculate. For quasi-periodic ...
%                                       solutions, the key is 'quasiperiodic' or 'qps'.
%                   - 'approx_method':  Defines the approximation method used to calculate approximate solutions of equation (3). ...
%                                       For the SHM, the key is 'shooting' or 'shm'.
%                   - 'cont':           As we want to execute a continuation, we set 'cont' = 'on'. If 'cont' = 'off', CoSTAR would ...
%                                       only calculate the initial solution Z0.
%                   - 'stability':      CoSTAR computes the stability of the solution if 'stability' = 'on'. Stability calculation ...
%                                       for quasi-periodic solutions is available when using the SHM, so we set it to 'on'. ...
% Opt-Need. field:  - 'non_auto_freq':  Function handle setting the non-autonomous frequency(s) of the system. 'non_auto_freq' must ...
%                                       be set if the system exhibits excitation frequency(s) and is not allowed otherwise.
%                   - 'act_param':      As we want to do a continuation, we have to tell CoSTAR where the continuation parameter is ...
%                                       located within param. To do that, we use the previously defined variable "active_parameter". ... 
%                                       Here, this field NEEDS to be set, because we provided a "param" array. If there is no ...
%                                       "param" array, 'act_param' must not be set.
%
% Going on, we have to set the "options.opt_init" structure. The fields of the "options.opt_init" structure depend on the solution ...
% type as well as the chosen approximation method. For quasi-periodic solutions using the SHM, there are two possibilities to define ...
% parameters used to determine the initial value. Overall, there are five optional fields, of which a maximum of four may be used. ...
% It is not allowed to use 'iv' in combination with the other fields.
options.opt_init = costaropts('ic',IC,'tinit',2000,'deltat',1000,'dt',0.1);
% Optional fields: - 'ic':      Possibility 1: Sets the initial point for the first time integration in state space. This ...
%                               integration aims at approaching the initial solution at mu0.
%                               -> Allowed values: [dim x 1] (double) array
%                               -> Default value:  zeros(dim,1)
%                  - 'tinit':   Possibility 1: Sets the integration time for the first integration.
%                               -> Allowed values: positive scalar
%                               -> Default value:  10000
%                  - 'deltat':  Possibility 1: Sets the integration time for the second integration (starting at the last point of ...
%                               the first integration). The initial value for fsolve is extracted from the trajectory of the second ...
%                               integration. This trajectory is assumed to be close enough to the initial solution at mu0.
%                               -> Allowed values: positive scalar
%                               -> Default value:  15000
%                   - 'dt':     Possibility 1: Sets the integration increment for the second integration. Choose a sufficiently ...
%                               small number to ensure that the trajectory is resolved adequately.
%                               -> Allowed values: positive scalar
%                               -> Default value: 0.1
%                   - 'iv':     Possibility 2: Can be used INSTEAD OF the fields above. 'iv' directly defines the initial value on ...
%                               the manifold edge (without autonomous frequency(s) and continuation parameter), i.e. 'iv' corresponds ...
%                               to the method solution vector s. Ideal for starting from a previously calculated point on the curve. ...
%                               If n_char_iv = numel(iv)/dim does not match the value of the opt_approx_method field "n_char" (or ...
%                               its default value, see below), "iv" is interpolated. 
%                               -> Allowed values: [n_char_iv*dim] (double) array
%                               -> Default value:  (no default value)
% NOTE: It is not necessary to set 'dt' since the default value is used. However, it is demonstrated here in order to show the ...
%       field and a possible value. For usage of the field 'iv', please see section 1.4.
%                  
% So far we have defined all "options" structures which CoSTAR always needs. Since we want to calculate a quasi-periodic solution ...
% and execute a continuation, we also have to set the "options.opt_approx_method" as well as the "options.opt_cont" structures. The ...
% fields of the "options.opt_approx_method" structure depend on the solution type as well as the chosen approximation method. For ...
% quasi-periodic solutions using the SHM, there are no mandatory fields and two optional fields.
options.opt_approx_method = costaropts('solver','ode45','n_char',40);
% Optional fields: - 'solver':  Sets the the MATLAB-proprietary numerical time integration algorithm. Use specialised solvers for ...
%                               stiff ODEs, e.g. ode15s.
%                               -> Allowed values: 'ode45', 'ode78', 'ode89', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb'
%                               -> Default value:  'ode45'
%                  - 'n_char':  Sets the number of characteristic curves which approximate the sought torus function. More ...
%                               characteristics improve the resolution but lead to higher numerical costs. Use a large number for ...
%                               complex manifolds.
%                               -> Allowed values: positive integer
%                               -> Default value:  100
% NOTE: It is not necessary to set 'solver' since the default value is used. However, it is demonstrated here in order to show ...
%       the field and a possible value.
%
options.opt_cont = costaropts('mu_limit',mu_limit,'step_width',0.25,'step_control_param',[3,5/180*pi]);
% Mandatory fields: - 'mu_limit':            Sets the limits of the continuation. For this purpose, we defined the "mu_limit" variable.
% Optional fields:  - 'step_width':          Defines the initial step width (default: 0.1). The step width will be altered in the ...
%                                            range of step_width*[0.2, 5].
%                   - 'step_control_param':  Sets properties for the step control (default value for step control method 'angle', ...
%                                            which is used here: [3,3/180*pi]).
% NOTE: The fields belonging to the step control ('step_width' and 'step_control_param') are set in order to reduce the numerical ...
%       effort. They are explained in a separate step control tutorial so you can ignore them at the moment.
% 
% Finally, we are done defining the required settings. All solution type and approximation method specific fields, which are the ...
% fields of "options.opt_init" and "options.opt_approx_method", were explained above. Concerning the rest of the "options" structures ...
% ("options.system", "options.opt_sol", "options.opt_cont" and "options.opt_stability"), only the necessary fields were defined and ...
% explained to some extend.
% If you want to have a deeper insight into the "options" structures and its fields, please use the "costarhelp" function by typing ...
% "costarhelp.options" in the command window. In order to directly open the help pages of particular "options" structures, type ...
% "costarhelp.<name_of_options_structure>", e.g. "costarhelp.opt_cont". In case of "options.opt_init", "options.opt_approx_method" ...
% and "options.opt_stability", type "costarhelp.<name_of_options_structure>('QPS','SHM')" ("QPS": Quasi-Periodic Solution).


%     1.2.3 Calling CoSTAR and running the simulation
%
% Now we can run the computation. This is done by invoking the "costar" function and passing the "options" structure as an input ...
% argument. "costar" returns two objects: 
% - DynamicalSystem object "DYN":  Saves all the information and settings which are contained in "options". It can be used to ...
%                                  restart the computation and it is necessary for postprocessing.
% - Solution object "S": Stores the information that CoSTAR calculated and can further be used for postprocessing.
%
[S,DYN] = costar(options);                          % CoSTAR is called by costar(options).
%
% During the computation, CoSTAR displays information in the command window:
% - At the beginning, the iteration process of fsolve trying to find the first point on the curve is shown.
% - As soon as fsolve succeeded, CoSTAR announces "Initial solution found!".
% - After that, CoSTAR displays "Iter: <XXX> -- mu = <XXX> -- stepwidth = <XXX>" when a new point on the curve has been calculated.
%       * "Iter" depicts the number of points on the curve which already have been calculated.
%       * "mu" shows the value of the continuation parameter mu at the latest point on the curve.
%       * "stepwidth" displays the step width that was used to calculate the latest point on the curve.
% - When the step width was adapted, CoSTAR shows the new step width and some additional information. You can ignore it at this point.
% - Finally, CoSTAR reports the reason of termination of the continuation.
%
% Apart from the information in the command window, CoSTAR plots the maximum of the Euclidean norm of the torus function against ...
% the continuation parameter mu. This means that for every computed approximate solution Z(theta_1,theta_2,mu), the Euclidean norm ...
% of (64*64) torus function points is calculated. These points are equidistant distributed on the hyper-time domain. After the ...
% Euclidean norm of all torus function points were computed, the maximum thereof is taken and plotted against mu. This is ...
% essentially a projection of the curve in R^(n+1)-dimensional space into 2D space. Stable solutions are depicted in blue while ...
% unstable solutions are shown in red (attention: if the solution stability is not calculated, the curve is depicted in blue as well!).
%
% Moreover, unstable solutions are depicted in red since we set the field 'stability' of the "options.opt_sol" structure to 'on'. ...
% CoSTAR also computed bifurcation points, which are shown in the plot ("BF": bifurcation). Details are saved to the field ...
% 'bifurcation' of the solution object S.
% It is pointed out again that details of the computation of stability and bifurcation points are addressed in a separate tutorial ...
% and are therefore not explained here. 


%                1.3 Postprocessing                 %
%
% In order to plot the hyper-time surfaces Z_i(theta_1,theta_2,mu) (torus function components), we need to call the "solplot" ...
% function. Similar to the "costar" function, solplot expects a structure that defines all required options for the plot.
solplot_options_1 = costaropts('zaxis',@(z) z(:,:,1),'space','hypertime','resolution',40,'index',[10,100]);
% Mandatory fields: - 'zaxis':       Defines what is plotted on the vertical axis. "@(z) z(:,:,1)" plots the first component (i = 1) ...
%                                    of the torus function against the hyper-time domain [0, 2*pi]^2.
%                   - 'space':       Specifies the "domain" of the plot. 'hypertime' plots the hyper-time surfaces of the solution.
% Optional fields:  - 'resolution':  Sets the number of points for the plot in each theta-direction.
%                   - 'index':       Defines at which points Z_i(theta_1,theta_2,mu) is plotted, e.g. if index = 25, the solution at ...
%                                    point number 25 (i.e. the 25th point which was calculated) is plotted
%
% Now we can call the "solplot" function. It is a function of the solution class object S, which is why we have to call it by ...
% "S.solplot". Apart from the "opt_solplot" structure, solplot also requires the DynamicalSystem class object DYN. 
% solplot creates the desired plot and additionally returns a structure storing the corresponding z-values, hypertime values and mu-values.
% However, the fields of the output structure depends on the options, so it may change in other cases.
solplot_output_1 = S.solplot(DYN,solplot_options_1);
%
% We do not go into further postprocessing details here as this would exceed the scope of this tutorial.
% Comprehensive explanations of the postprocessing functions can be found in the corresponding tutorials ...
% (Tutorial_Postprocessing_<...>: contplot, solget and solplot) and the associated examples provide short exemplary code. 
% An overview of the available options is given via the costarhelp function by typing "costarhelp.costar" in the command window.


%      1.4 Change of the continuation parameter      %
%
% In the example explained above, the continuation parameter was the excitation frequency eta. How does the "options" structure need ...
% to be modified if we want to vary a different parameter, let's say the coefficient of the nonlinear stiffness kappa?
% Think about it before you continue with this tutorial! If you are not sure which parameters or in what sense parameters need to ...
% be adjusted, please scroll up and read the section "1.2.1 Setting useful variables" again.
%
% First of all, we define new limits for the continuation and set the starting value kappa0:
mu_limit_kappa = [1, 2];
kappa0 = mu_limit_kappa(1);
% We do not change the values of the other parameters (D = 0.05, f1 = f2 = 0.25, ratio = sqrt(2)). Of course, the function ...
% handle Fcn also remains.
% In contrast to the continuation above, we need to fix the excitation frequency eta since CoSTAR accepts only one continuation ...
% parameter, which is kappa in this case. We set
eta_kappa = 1.5;
% Furthermore, we need to define a new function handle "non_auto_freq_kappa" using eta_kappa:
non_auto_freq_kappa = @(mu) [eta_kappa, ratio*eta_kappa];
% Now we can define a new "param" array and set the active parameter:
param_kappa = {D, kappa0, f1, f2, eta_kappa, ratio};   
active_parameter_kappa = 2;
% Instead of time integration, we use the field 'iv' this time in order to directly provide an initial value. For 'iv', we take ...
% the first solution point of the continuation above, which is the first column of the field 's' of the solution object S. ...
% Furthermore, we change the number of characteristics to 50, so IV is interpolated to adapt to the new number of 'n_char'.
IV = S.s(:,1);
%
options_kappa.system = costaropts('order',1,'dim',2,'rhs',Fcn,'param',param_kappa,'info','Continuation of Quasi-Periodic Duffing Equation - kappa');
options_kappa.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','shooting','cont','on','stability','on', ...
                                   'non_auto_freq',non_auto_freq_kappa,'act_param',active_parameter_kappa);
options_kappa.opt_init = costaropts('iv',IV);                                   % The field 'iv' is used this time
options_kappa.opt_approx_method = costaropts('solver','ode45','n_char',50);     % We change the number of characteristics to 40
options_kappa.opt_cont = costaropts('mu_limit',mu_limit_kappa,'step_width',0.05);
%
[S_kappa,DYN_kappa] = costar(options_kappa); 
%
% That's it! Now you also know how to set up CoSTAR if the excitation frequency is not the continuation parameter.
%
% Additional question (optional): Compare the last continuation plot of section 1.4 with the continuation plot of section 1.4 of ...
%                                 the QPS-FDM-Tutorial (pay attention to the vertical axis). Why are they not identical even though ...
%                                 the same parameters are used? Hint: The different accuracies of the FDM and SHM are not the reason!
%                                 Answer can be found to the right ->                                                                                   The continuation plot of section 1.2 reveals three different solutions for eta = 1.5. ...
%                                                                                                                                                       In the QPS-FDM-Tutorial, fsolve converges towards the upper solution, while fsolve ...
%                                                                                                                                                       converges towards the buttom solution in this tutorial.

% Finally, we are done with the "Duffing Oscillator" example!
% Going on, we will learn how to deal with mixed systems exhibiting one excitation frequency and one autonomous frequency on the ...
% basis of the Jeffcott(-Laval) rotor.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Example No. 2: Jeffcott(-Laval) Rotor      %%
%          Mixed / Half-Autonomous System           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
clear variables; clc; close all;                    % Let's clean our "desk" before we begin with our second example.

%               2.1  Introduction                   %
%
% After having discussed a non-autonomous system with two excitation frequencies, we will turn to "mixed" systems exhibiting ...
% external forcing as well as self excitation. As an example, we take a Jeffcott(-Laval) rotor with external and internal damping, ...
% gravitational influence and nonlinear cubic damping forces. The second-order ODE reads:
%       x'' + 2*Di*(1+delta)*x' + d3*(x')^3 + x - 2*Di*eta*y = e*(eta^2)*sin(eta*tau)           (4.1)
%       y'' + 2*Di*(1+delta)*y' + d3*(y')^3 + y + 2*Di*eta*x = e*(eta^2)*cos(eta*tau) - Fg      (4.2)
% where x and y are the coordinates of the deflection, Di is the factor of internal damping, delta is the ratio of external to ...
% internal damping, d3 is the coefficient of the nonlinear damping, eta is the dimensionless rotational speed, e is the ...
% eccentricity and tau is the dimensionless time. Following that, x' = dx/dtau and x'' = dx'/dtau holds. CoSTAR always needs the ...
% equation to be of the form dz/dt = f(t,z,param) (param represents all additional parameters), which is why we have to transform ...
% (4) into a system of four differential equations of first order. To do that, we introduce the state variable vector ...
% z = [z1; z2; z3; z4] = [x; y; x'; y'], leading to:
% dz/dtau = f(tau,z,eta,Di,delta,e,d3,Fg)  (5)  
%                              <=>  z1' = z3
%                                   z2' = z4
%                                   z3' = - 2*Di*(1+delta)*z3 - d3*z3^3 - z1 + 2*Di*eta*z2 + e*(eta^2)*sin(eta*tau);
%                                   z4' = - 2*Di*(1+delta)*z4 - d3*z4^3 - z2 - 2*Di*eta*z1 + e*(eta^2)*cos(eta*tau) - Fg;
%
% The system exhibits a quasi-periodic solution z(tau) for eta in the range of [1.72, 2.5] (and the parameters defined as below), ...
% which we want to approximate using the SHM. Instead of the quasi-periodic solution itself, we calculate the (image of the) torus ...
% function Z = Z(theta_1,theta_2) that describes the torus on which the quasi-periodic solution evolves, using the hyper-time ...
% invariance equation:
% dZ/dtheta_1 * Omega_1 + dZ/dtheta_2 * omega_2 = f(Z,theta_1,theta_2,param)   (6),
% where Omega_1 = eta is the excitation frequency, omega_2 is the unknown autonomous frequency and f is the right-hand side of (5).
% This problem can be rewritten into finding the zero set of the function g: R^(n+2) -> R^(n+1) with g = 0 and for eta in [1.72, 2.5], ...
% which defines a curve in (n+2)-dimensional space (n depends on the dimension of the system as well as the discretisation). Hence, ...
% a solution Z(theta_1,theta_2) is also denoted as a "point on the curve" in the following explanations. CoSTAR will approximate ...
% discrete points on this curve by executing a path continuation. As the frequency eta is varied, the continuation parameter is ...
% mu = eta. The remaining parameters are set to:
Di = 0.2;       delta = 1/3;        d3 = 0.25;
e = 0.25;       Fg = 0.3924; 


%       2.2 Continuation of rotational speed        %
%
%          2.2.1 Setting useful variables           
%
% Before we specify the settings needed by CoSTAR, we introduce some important variables, which we will use later on. This is not ...
% necessarily needed but it helps to keep an overview of the most important variables/settings. Furthermore, important aspects of ...
% CoSTAR are explained here, making the following section "2.2.2 The CoSTAR settings" clearer.
mu_limit = [1.72, 2.5];                 % mu_limits = eta_limits = [1.72, 2.5] sets the upper and bottom limit of our continuation.
%
eta0 = mu_limit(2);                     % eta0 defines the eta-value at which the continuation begins. We start at the upper limit.
%
Fcn =  @(t,z,param) laval_qp(t,z,param);    % Fcn is a function handle containing the right-hand side (RHS) of equation (5). 
% You may have noticed that Fcn is a function of t, z and param, whereas the right-hand side of (5) is a function of tau, z, ...
% eta, Di, delta, e, d3 and Fg. This is because CoSTAR ALWAYS requires the definition of Fcn as "Fcn = @(t,z,param) ..." when ...
% calculating quasi-periodic solutions. param is a cell array storing all parameters, apart from t and z, that need to be passed ...
% to (5). The time t as well as the state variable vector z are always treated separately and therefore not included in param. ...
% Here, we need to define param since we need to pass the parameters eta, Di, delta, e, d3 and Fg to Fcn. The name of the ...
% "time argument" being t (and not tau) is required by CoSTAR. It is equal to our dimensionless time tau.
%
% TASK: Open the function "laval_qp" (click the right mouse button right on it and choose 'Open "laval_qp"' or go into ...
%       the "RHS" subfolder located in the main path of CoSTAR and double click on the function). Have a look at how the equation ...
%       is defined and compare that to our system directly below of equation (5).
% IMPORTANT: Please pay attention to how the state variables z1, z2, z3 and z4 are defined and how the parameters eta, Di, delta, ...
%            e, d3 and Fg are extracted from param. Moreover, pay attention to the definition and explanation of the time variables ...
%            t1 and t2, which is especially important when dealing with quasi-periodic solutions of forced systems.
%
% Now we define the "param" array. It is important that this is a cell array AND the order of the parameters placed in param must ...
% correspond to the definitions in the "laval_qp" function! For example, Di is defined by Di = param{2} in the "laval_qp" function. ...
% Therefore, Di has to be the SECOND variable in the "param" array. For the variable eta, we use eta0 since the continuation starts ...
% at the eta-value of eta0.
param = {eta0, Di, delta, e, d3, Fg};
% Next, we have to tell CoSTAR where the continuation parameter is located within param. We also call this the "active parameter". ...
% This is done by defining an integer variable which is used to get the continuation parameter from param by cell indexing, i.e. ...
% continuation parameter mu = param{active_parameter}. As we want to continue the curve via eta and the corresponding value eta0 ...
% is the FIRST element of param, we set:
active_parameter = 1;
%
% Going on, we need to set the non-autonomous frequency of the external forcing (eta). This sounds a bit confusing since eta is ...
% the continuation parameter mu and we already set the range of the continuation by defining mu_limit. So why do we need to specify ...
% the non-autonomous frequency again? The reason is that eta CAN be the continuation parameter but does NOT HAVE TO BE the ...
% continuation parameter. In order to deal with this uncertainty, we introduce a function handle which sets the non-autonomous ...
% frequency. In this case, the non-autonomous frequency is the continuation parameter mu, so we set
non_auto_freq = @(mu) mu;
% "non_auto_freq" ALWAYS have to be a function handle @(mu), even if it is not dependent on mu! For example, if we want to vary the ...
% damping factor Di, the non-autonomous frequency would have to be fixed, let us say eta = 1.5. In that case, we would have to ...
% define the function handle as non_auto_freq = @(mu) 1.5. This rather unconventional approach not only keeps the code as compact ...
% as possible but also allows a great flexibility for the user since the non-autonomous frequency can be an arbitrary function of ...
% mu (e.g. we can set non_auto_freq = @(mu) 10*mu etc.).
% Moreover, we have to set an initial "guess" for the autonomous frequency, which CoSTAR uses as an initial value (IV) for the ...
% autonomous frequencies when iterating to the first point on the curve. This parameter is called "auto_freq" and we set it to
auto_freq = 1;
%
% Last but not least, we set variables which are used to create an initial value where the nonlinear system solver fsolve starts ...
% to find the first approximate solution of equation (6) at mu0 (i.e. the first point on the curve). Using the quasi-periodic ...
% shooting method, the initial value consists of n_char points that are distributed equidistantly on the manifold edge theta_1 = 0 ...
% (theta_2_i = i * DeltaTheta_2 for DeltaTheta_2 = 2*pi/n_char and i = 0, 1, 2, ... , n_char-1). Starting from these points, n_char ...
% characteristic curves (characteristics) are computed using time integration until the manifold edge at theta_1 = 2*pi is reached. ...
% These characteristics approximate the sought manifold Z(theta_1,theta_2,mu) if Z(0,theta_2,mu) = Z(2*pi,theta_2,mu) holds. The ...
% n_char points of the solution Z(theta_1,theta_2,mu) at (theta_1=0,theta_2_i) then form the method solution vector s, which is ...
% stored in the solution object S.
% The initial value for fsolve is generated based on a trajectory computed via time integration starting at an initial point called ...
% 'ic'. After an integration time of 'tinit', the trajectory is assumed to be close enough to the sought solution. Subsequently, ...
% another integration is started. In general, the trajectory of the latter integration does not fill the sought torus yet, but it ...
% is close enough to the manifold to generate the initial value for fsolve. Therefore, the initial value is extracted from this ...
% trajectory. For our Jeffcott-Laval rotor example, we set the initial point ic to:
IC = 0.5.*ones(4,1);


%            2.2.2 The CoSTAR settings              
%
% All information and settings which CoSTAR needs are defined in a structure array called "options". 
% The structure "options" itself consists of structure arrays that define important parameters used by different modules of CoSTAR.
% 
% CoSTAR ALWAYS needs the following "option" structures: "options.system", "options.opt_sol" and "options.opt_init".
% Depending on the system and problem, CoSTAR might need some or all of the following "option" structures additionally: 
% "options.opt_approx_method":  Required when calculating (quasi-) periodic solutions.
% "options.opt_cont":           Required when running a continuation.
% "options.opt_stability":      Optional when calculating the stability of solutions.
% In this case, all of the three additional "option" structures are needed.
% 
% Each of the "option" structures contain mandatory fields which ALWAYS have to be set. 
% Furthermore, there are optional fields that CAN be set. Most of the optional fields have a default value. 
% However, even optional fields NEED to be set in some cases (denoted as "Opt-Need.", e.g. 'param' in this example, see below).
% 
% IMPORTANT: All option structures must be created by the "costaropts" function. The syntax of the arguments of "costaropts" is ...
%            equivalent to the MATLAB struct function, i.e. costaropts(fieldname1,value1,...,fieldnameN,valueN).
%
% Let us start with the "options.system" structure:
options.system = costaropts('order',1,'dim',4,'rhs',Fcn,'param',param,'info','Continuation of Jeffcott-Laval Rotor');
% Mandatory fields: - 'order':  Describes the order of the ODE. As CoSTAR takes a system of differential equations of first order ...
%                               ( dz/dt = f(t,z,param) ), the order is 1.
%                   - 'dim':    Dimension of the state space. In this case, the dimension of the state variable vector z is 4.
%                   - 'rhs':    Right-hand side of equation (5), which we already assigned to the variable Fcn.                
% Opt-Need. field:  - 'param':  This field expects the previously defined "param" array. We NEED to set it because it is required ...
%                               by Fcn. Moreover, when executing a continuation, param is always necessary. However, param CAN be ...
%                               omitted when only calculating the initial solution (i.e. no continuation is carried out).
% Optional field:   - 'info':   Contains your individual text about the computation. This does not need to be set. However, it may ...
%                               help you later if you have forgotten what this computation is about (default: no text).
%
% Next, there is the "options.opt_sol" structure:
options.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','shooting','cont','on','stability','on', ...
                             'non_auto_freq',non_auto_freq,'auto_freq',auto_freq,'act_param',active_parameter);
% Mandatory fields: - 'sol_type':       We need to specify what type of solution CoSTAR has to calculate. For quasi-periodic ...
%                                       solutions, the key is 'quasiperiodic' or 'qps'.
%                   - 'approx_method':  Defines the approximation method used to calculate approximate solutions of equation (6). ...
%                                       For the SHM, the key is 'shooting' or 'shm'.
%                   - 'cont':           As we want to execute a continuation, we set 'cont' = 'on'. If 'cont' = 'off', CoSTAR would ...
%                                       only calculate the initial solution Z0.
%                   - 'stability':      CoSTAR computes the stability of the solution if 'stability' = 'on'. Stability calculation ...
%                                       for quasi-periodic solutions is available when using the SHM, so we set it to 'on'. ...
% Opt-Need. field:  - 'non_auto_freq':  Function handle setting the non-autonomous frequency(s) of the system. 'non_auto_freq' must ...
%                                       be set if the system exhibits excitation frequency(s) and is not allowed otherwise.
%                   - 'auto_freq':      Sets the initial value for the autonomous frequency(s) of the system. 'auto_freq' must be ...
%                                       set if the system exhibits autonomous frequency(s) and is not allowed otherwise.
%                   - 'act_param':      As we want to do a continuation, we have to tell CoSTAR where the continuation parameter is ...
%                                       located within param. To do that, we use the previously defined variable "active_parameter". ... 
%                                       Here, this field NEEDS to be set, because we provided a "param" array. If there is no ...
%                                       "param" array, 'act_param' must not be set.
%
% Going on, we have to set the "options.opt_init" structure. The fields of the "options.opt_init" structure depend on the solution ...
% type as well as the chosen approximation method. For quasi-periodic solutions using the SHM, there are two possibilities to define ...
% parameters used to determine the initial value. Overall, there are five optional fields, of which a maximum of four may be used. ...
% It is not allowed to use 'iv' in combination with the other fields.
options.opt_init = costaropts('ic',IC,'tinit',1000,'deltat',1000,'dt',0.1);
% Optional fields: - 'ic':      Possibility 1: Sets the initial point for the first time integration in state space. This ...
%                               integration aims at approaching the initial solution at mu0.
%                               -> Allowed values: [dim x 1] (double) array
%                               -> Default value:  zeros(dim,1)
%                  - 'tinit':   Possibility 1: Sets the integration time for the first integration.
%                               -> Allowed values: positive scalar
%                               -> Default value:  10000
%                  - 'deltat':  Possibility 1: Sets the integration time for the second integration (starting at the last point of ...
%                               the first integration). The initial value for fsolve is extracted from the trajectory of the second ...
%                               integration. This trajectory is assumed to be close enough to the initial solution at mu0.
%                               -> Allowed values: positive scalar
%                               -> Default value:  15000
%                   - 'dt':     Possibility 1: Sets the integration increment for the second integration. Choose a sufficiently ...
%                               small number to ensure that the trajectory is resolved adequately.
%                               -> Allowed values: positive scalar
%                               -> Default value: 0.1
%                   - 'iv':     Possibility 2: Can be used INSTEAD OF the fields above. 'iv' directly defines the initial value on ...
%                               the manifold edge (without autonomous frequency(s) and continuation parameter), i.e. 'iv' corresponds ...
%                               to the method solution vector s. Ideal for starting from a previously calculated point on the curve. ...
%                               If n_char_iv = numel(iv)/dim does not match the value of the opt_approx_method field "n_char" (or ...
%                               its default value, see below), "iv" is interpolated. 
%                               -> Allowed values: [n_char_iv*dim] (double) array
%                               -> Default value:  (no default value)
% NOTE: It is not necessary to set 'dt' since the default value is used. However, it is demonstrated here in order to show the ...
%       field and a possible value. For usage of the field 'iv', please see section 1.4 of the "Duffing Oscillator" example above.
%                  
% So far we have defined all "options" structures which CoSTAR always needs. Since we want to calculate a quasi-periodic solution ...
% and execute a continuation, we also have to set the "options.opt_approx_method" as well as the "options.opt_cont" structures. The ...
% fields of the "options.opt_approx_method" structure depend on the solution type as well as the chosen approximation method. For ...
% quasi-periodic solutions using the SHM, there are no mandatory fields and two optional fields.
options.opt_approx_method = costaropts('solver','ode45','n_char',25);
% Optional fields: - 'solver':  Sets the the MATLAB-proprietary numerical time integration algorithm. Use specialised solvers for ...
%                               stiff ODEs, e.g. ode15s.
%                               -> Allowed values: 'ode45', 'ode78', 'ode89', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb'
%                               -> Default value:  'ode45'
%                  - 'n_char':  Sets the number of characteristic curves which approximate the sought torus function. More ...
%                               characteristics improve the resolution but lead to higher numerical costs. Use a large number for ...
%                               complex manifolds.
%                               -> Allowed values: positive integer
%                               -> Default value:  100
% NOTE: It is not necessary to set 'solver' since the default value is used. However, it is demonstrated here in order to show ...
%       the field and a possible value.
%
options.opt_cont = costaropts('mu_limit',mu_limit,'step_width',0.2,'direction',-1);
% Mandatory fields: - 'mu_limit':            Sets the limits of the continuation. For this purpose, we defined the "mu_limit" variable.
% Optional fields:  - 'step_width':          Defines the initial step width (default: 0.1). The step width will be altered in the ...
%                                            range of step_width*[0.2, 5].
%                   - 'direction':           We start the continuation at the upper limit of mu, so we need to decrease mu during ...
%                                            the continuation. This is done by setting the field 'direction' to -1 (default: 1).
% NOTE: The field belonging to the step control ('step_width') is set in order to reduce the numerical effort. Step control is ...
%       explained in a separate step control tutorial so you can ignore it at the moment.
%
% Finally, we are done defining the required settings. All solution type and approximation method specific fields, which are the ...
% fields of "options.opt_init" and "options.opt_approx_method", were explained above. Concerning the rest of the "options" structures ...
% ("options.system", "options.opt_sol", "options.opt_cont" and "options.opt_stability"), only the necessary fields were defined and ...
% explained to some extend.
% If you want to have a deeper insight into the "options" structures and its fields, please use the "costarhelp" function by typing ...
% "costarhelp.options" in the command window. In order to directly open the help pages of particular "options" structures, type ...
% "costarhelp.<name_of_options_structure>", e.g. "costarhelp.opt_cont". In case of "options.opt_init", "options.opt_approx_method" ...
% and "options.opt_stability", type "costarhelp.<name_of_options_structure>('QPS','SHM')" ("QPS": Quasi-Periodic Solution).


%     2.2.3 Calling CoSTAR and running the simulation
%
% Now we can run the computation. This is done by invoking the "costar" function and passing the "options" structure as an input ...
% argument. "costar" returns two objects: 
% - DynamicalSystem object "DYN":  Saves all the information and settings which are contained in "options". It can be used to ...
%                                  restart the computation and it is necessary for postprocessing.
% - Solution object "S": Stores the information that CoSTAR calculated and can further be used for postprocessing.
%
[S,DYN] = costar(options);                          % CoSTAR is called by costar(options).
%
% During the computation, CoSTAR displays information in the command window:
% - At the beginning, the iteration process of fsolve trying to find the first point on the curve is shown.
% - As soon as fsolve succeeded, CoSTAR announces "Initial solution found!".
% - After that, CoSTAR displays "Iter: <XXX> -- mu = <XXX> -- stepwidth = <XXX>" when a new point on the curve has been calculated.
%       * "Iter" depicts the number of points on the curve which already have been calculated.
%       * "mu" shows the value of the continuation parameter mu at the latest point on the curve.
%       * "stepwidth" displays the step width that was used to calculate the latest point on the curve.
% - When the step width was adapted, CoSTAR shows the new step width and some additional information. You can ignore it at this point.
% - Finally, CoSTAR reports the reason of termination of the continuation.
%
% Apart from the information in the command window, CoSTAR plots the maximum of the Euclidean norm of the torus function against ...
% the continuation parameter mu. This means that for every computed approximate solution Z(theta_1,theta_2,mu), the Euclidean norm ...
% of (64*64) torus function points is calculated. These points are equidistant distributed on the hyper-time domain. After the ...
% Euclidean norm of all torus function points were computed, the maximum thereof is taken and plotted against mu. This is ...
% essentially a projection of the curve in R^(n+2)-dimensional space into 2D space. Stable solutions are depicted in blue while ...
% unstable solutions are shown in red (attention: if the solution stability is not calculated, the curve is depicted in blue as well!).
%
% Moreover, unstable solutions are depicted in red since we set the field 'stability' of the "options.opt_sol" structure to 'on'. ...
% CoSTAR can also compute bifurcation points, but in this case, there are not any.
% It is pointed out again that details of the computation of stability and bifurcation points are addressed in a separate tutorial ...
% and are therefore not explained here. 


%                2.3 Postprocessing                 %
%
% In order to plot the hyper-time surfaces Z_i(theta_1,theta_2,mu) (torus function components), we need to call the "solplot" ...
% function. Similar to the "costar" function, solplot expects a structure that defines all required options for the plot.
solplot_options_2 = costaropts('zaxis',@(z) z(:,:,1),'space','hypertime','resolution',25,'index',[5,30]);
% Mandatory fields: - 'zaxis':       Defines what is plotted on the vertical axis. "@(z) z(:,:,1)" plots the first component (i = 1) ...
%                                    of the torus function against the hyper-time domain [0, 2*pi]^2.
%                   - 'space':       Specifies the "domain" of the plot. 'hypertime' plots the hyper-time surfaces of the solution.
% Optional fields:  - 'resolution':  Sets the number of points for the plot in each theta-direction.
%                   - 'index':       Defines at which points Z_i(theta_1,theta_2,mu) is plotted, e.g. if index = 25, the solution at ...
%                                    point number 25 (i.e. the 25th point which was calculated) is plotted
%
% Now we can call the "solplot" function. It is a function of the solution class object S, which is why we have to call it by ...
% "S.solplot". Apart from the "opt_solplot" structure, solplot also requires the DynamicalSystem class object DYN. 
% solplot creates the desired plot and additionally returns a structure storing the corresponding z-values, hypertime values and mu-values.
% However, the fields of the output structure depends on the options, so it may change in other cases.
solplot_output_2 = S.solplot(DYN,solplot_options_2);
%
% We do not go into further postprocessing details here as this would exceed the scope of this tutorial.
% Comprehensive explanations of the postprocessing functions can be found in the corresponding tutorials ...
% (Tutorial_Postprocessing_<...>: contplot, solget and solplot) and the associated examples provide short exemplary code. 
% An overview of the available options is given via the costarhelp function by typing "costarhelp.costar" in the command window.


% Now we are done with the "Jeffcott(-Laval) Rotor" example!
% Going on, we will learn how to deal with full autonomous systems, exhibiting no external forcing, on the basis of two coupled ...
% van der Pol oscillators.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    Ex. No 3: Coupled van der Pol Oscillator     %%
%              Full Autonomous System               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
clear variables; clc; close all;                    % Let's clean our "desk" before we begin with our second example.

%                3.1 Introduction                   %
%
% The third example we have a look on are two coupled van der Pol oscillators which are given by the dimensionless differential equations
%   x1'' + epsilon * (x1^2 - 1) * x1' +              x1 = alpha * (x2 - x1)     (7.1)
%   x2'' + epsilon * (x2^2 - 1) * x2' + (1 + beta) * x2 = alpha * (x1 - x2)     (7.2)
% epsilon is the coefficient of the non-linearity, alpha the coupling constant, beta a constant of the linear stiffness of x2, ...
% xi' = dxi/dtau and xi'' = dxi'/dtau (i = 1,2; tau being the dimensionless time). However, CoSTAR always needs the equation to be ...
% of the form dz/dt = f(t,z,param) (param represents all additional parameters), which is why we have to transform (7) into a ...
% system of four differential equations of first order. To do that, we introduce the state variable vector ...
% z = [z1; z2; z3; z4] = [x1; x2; x1'; x2'], leading to:
% dz/dtau = f(z,epsilon,alpha,beta)  (8)  <=>  z1' = z3
%                                              z2' = z4
%                                              z3' = - epsilon * (z1^2 - 1) * z3 -            z1 + alpha * (z2 - z1)
%                                              z4' = - epsilon * (z2^2 - 1) * z4 - (1+beta) * z2 + alpha * (z1 - z2)
%
% Our aim is to approximate the quasi-periodic solution of equation (8) z(tau) for epsilon in the range of [0.1, 1.25] using the SHM. ...
% Instead of the quasi-periodic solution itself, we calculate the (image of the) torus function Z = Z(theta_1,theta_2) that ...
% describes the torus on which the quasi-periodic solution evolves, using the hyper-time invariance equation:
% dZ/dtheta_1 * omega_1 + dZ/dtheta_2 * omega_2 = f(Z,theta_1,theta_2,param)   (9),
% where omega_1 and omega_2 are the unknown autonomous frequencies and where f is the right-hand side of (8). This problem can be ...
% rewritten into finding the zero set of the function g: R^(n+3) -> R^(n+2) with g = 0 and for epsilon in [0.1, 1.25], which defines ...
% a curve in (n+3)-dimensional space (n depends on the dimension of the system as well as the discretisation). Hence, a solution ...
% Z(theta_1,theta_2) is also denoted as a "point on the curve" in the following explanations. CoSTAR will approximate discrete ...
% points on this curve by executing a path continuation. As epsilon is varied, the continuation parameter is mu = epsilon. The ...
% remaining parameters are set to:
alpha = 0.1;    beta = 1.1;


%       3.2 Continuation of nonlinear damping       %
%
%          3.2.1 Setting useful variables           
%
% Before we specify the settings needed by CoSTAR, we introduce some important variables, which we will use later on. This is not ...
% necessarily needed but it helps to keep an overview of the most important variables/settings. Furthermore, important aspects of ...
% CoSTAR are explained here, making the following section "3.2.2 The CoSTAR settings" clearer.
mu_limit = [0.1, 1.25];                             % mu_limits = epsilon_limits = [0.1, 1.25] sets the limits of our continuation.
%
epsilon0 = mu_limit(1);                             % epsilon0 defines the epsilon-value at which the continuation begins.
%
Fcn = @(t,z,param) coupledvdp(t,z,param);           % Fcn is a function handle containing the right-hand side (RHS) of equation (8).
% You may have noticed that Fcn is a function of t, z and param, whereas the right-hand side of (8) is only a function of z, ...
% epsilon, alpha and beta. This is because CoSTAR ALWAYS requires the definition of Fcn as "Fcn = @(t,z,param) ..." when ...
% calculating quasi-periodic solutions. param is a cell array storing all parameters, apart from t and z, that need to be passed ...
% to (8). The time t as well as the state variable vector z are always treated separately and therefore not included in param. ...
% Here, we need to define param since we need to pass the parameters epsilon, alpha and beta to Fcn. The name of the ...
% "time argument" being t (and not tau) is required by CoSTAR. It is equal to our dimensionless time tau.
%
% TASK: Open the function "coupledvdp" (click the right mouse button right on it and choose 'Open "coupledvdp"' or go into the ...
%       "RHS" subfolder located in the main path of CoSTAR and double click on the function). Have a look at how the equation is  ...
%       defined and compare that to our system right next to equation (8).
% IMPORTANT: Please pay attention to how the state variables z1, z2, z3 and z4 are defined and how the parameters epsilon, alpha ...
%            and beta are extracted from param. Moreover, take notice the definition and explanation of the time variables t1 and t2.
%
% Now we define the "param" array. It is important that this is a cell array AND the order of the parameters placed in param must ...
% correspond to the definitions in the "coupledvdp" function! For example, alpha is defined by alpha = param{2} in the "coupledvdp" ...
% function. Therefore, alpha has to be the SECOND variable in the "param" array. For the variable epsilon, we use epsilon0 since ...
% the continuation starts at the epsilon-value of epsilon0.
param = {epsilon0, alpha, beta};
% Next, we have to tell CoSTAR where the continuation parameter is located within param. We also call this the "active parameter". ...
% This is done by defining an integer variable which is used to get the continuation parameter from param by cell indexing, i.e. ...
% continuation parameter mu = param{active_parameter}. As we want to continue the curve via epsilon and the corresponding value ...
% epsilon0 is the FIRST element of param, we set:
active_parameter = 1;
%
% Due to the system being fully autonomous, we have to set an initial "guess" for the autonomous frequencies, which CoSTAR uses as ...
% an initial value (IV) for the autonomous frequencies when iterating to the first point on the curve. This parameter is called ...
% "auto_freq" and we set it to
auto_freq = [1.04, 1.5];
% Last but not least, we set variables which are used to create an initial value where the nonlinear system solver fsolve starts ...
% to find the first approximate solution of equation (9) at mu0 (i.e. the first point on the curve). Using the quasi-periodic ...
% shooting method, the initial value consists of n_char points that are distributed equidistantly on the manifold edge theta_1 = 0 ...
% (theta_2_i = i * DeltaTheta_2 for DeltaTheta_2 = 2*pi/n_char and i = 0, 1, 2, ... , n_char-1). Starting from these points, n_char ...
% characteristic curves (characteristics) are computed using time integration until the manifold edge at theta_1 = 2*pi is reached. ...
% These characteristics approximate the sought manifold Z(theta_1,theta_2,mu) if Z(0,theta_2,mu) = Z(2*pi,theta_2,mu) holds. The ...
% n_char points of the solution Z(theta_1,theta_2,mu) at (theta_1=0,theta_2_i) then form the method solution vector s, which is ...
% stored in the solution object S.
% The initial value for fsolve is generated based on a trajectory computed via time integration starting at an initial point called ...
% 'ic'. After an integration time of 'tinit', the trajectory is assumed to be close enough to the sought solution. Subsequently, ...
% another integration is started. In general, the trajectory of the latter integration does not fill the sought torus yet, but it ...
% is close enough to the manifold to generate the initial value for fsolve. Therefore, the initial value is extracted from this ...
% trajectory. For our coupled van der Pol example, we set the initial point ic to:
IC = ones(4,1);


%            3.2.2 The CoSTAR settings              
%
% All information and settings which CoSTAR needs are defined in a structure array called "options". 
% The structure "options" itself consists of structure arrays that define important parameters used by different modules of CoSTAR.
% 
% CoSTAR ALWAYS needs the following "option" structures: "options.system", "options.opt_sol" and "options.opt_init".
% Depending on the system and problem, CoSTAR might need some or all of the following "option" structures additionally: 
% "options.opt_approx_method":  Required when calculating (quasi-) periodic solutions.
% "options.opt_cont":           Required when running a continuation.
% "options.opt_stability":      Optional when calculating the stability of solutions.
% In this case, all of the three additional "option" structures are needed.
% 
% Each of the "option" structures contain mandatory fields which ALWAYS have to be set. 
% Furthermore, there are optional fields that CAN be set. Most of the optional fields have a default value. 
% However, even optional fields NEED to be set in some cases (denoted as "Opt-Need.", e.g. 'param' in this example, see below).
% 
% IMPORTANT: All option structures must be created by the "costaropts" function. The syntax of the arguments of "costaropts" is ...
%            equivalent to the MATLAB struct function, i.e. costaropts(fieldname1,value1,...,fieldnameN,valueN).
%
% Let us start with the "options.system" structure: 
options.system   = costaropts('order',1,'dim',4,'rhs',Fcn,'param',param,'info','Continuation of Coupled van der Pol Oscillator');
% Mandatory fields: - 'order':  Describes the order of the ODE. As CoSTAR takes a system of differential equations of first order ...
%                               ( dz/dt = f(t,z,param) ), the order is 1.
%                   - 'dim':    Dimension of the state space. In this case, the dimension of the state variable vector z is 4.
%                   - 'rhs':    Right-hand side of equation (8), which we already assigned to the variable Fcn.                
% Opt-Need. field:  - 'param':  This field expects the previously defined "param" array. We NEED to set it because it is required ...
%                               by Fcn. Moreover, when executing a continuation, param is always necessary. However, param CAN be ...
%                               omitted when only calculating the initial solution (i.e. no continuation is carried out).
% Optional field:   - 'info':   Contains your individual text about the computation. This does not need to be set. However, it may ...
%                               help you later if you have forgotten what this computation is about (default: no text).
%
% Next, there is the "options.opt_sol" structure:
options.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','shooting','cont','on','stability','on', ...
                             'auto_freq',auto_freq,'act_param',active_parameter);
% Mandatory fields: - 'sol_type':       We need to specify what type of solution CoSTAR has to calculate. For quasi-periodic ...
%                                       solutions, the key is 'quasiperiodic' or 'qps'.
%                   - 'approx_method':  Defines the approximation method used to calculate approximate solutions of equation (9). ...
%                                       For the SHM, the key is 'shooting' or 'shm'.
%                   - 'cont':           As we want to execute a continuation, we set 'cont' = 'on'. If 'cont' = 'off', CoSTAR would ...
%                                       only calculate the initial solution Z0.
%                   - 'stability':      CoSTAR computes the stability of the solution if 'stability' = 'on'. Stability calculation ...
%                                       for quasi-periodic solutions is available when using the SHM, so we set it to 'on'. ...
% Opt-Need. field:  - 'auto_freq':      Sets the initial value for the autonomous frequency(s) of the system. 'auto_freq' must be ...
%                                       set if the system exhibits autonomous frequency(s) and is not allowed otherwise.
%                   - 'act_param':      As we want to do a continuation, we have to tell CoSTAR where the continuation parameter is ...
%                                       located within param. To do that, we use the previously defined variable "active_parameter". ... 
%                                       Here, this field NEEDS to be set, because we provided a "param" array. If there is no ...
%                                       "param" array, 'act_param' must not be set.
%
% Going on, we have to set the "options.opt_init" structure. The fields of the "options.opt_init" structure depend on the solution ...
% type as well as the chosen approximation method. For quasi-periodic solutions using the SHM, there are two possibilities to define ...
% parameters used to determine the initial value. Overall, there are five optional fields, of which a maximum of four may be used. ...
% It is not allowed to use 'iv' in combination with the other fields.
options.opt_init = costaropts('ic',IC,'tinit',1000,'deltat',2000,'dt',0.1);
% Optional fields: - 'ic':      Possibility 1: Sets the initial point for the first time integration in state space. This ...
%                               integration aims at approaching the initial solution at mu0.
%                               -> Allowed values: [dim x 1] (double) array
%                               -> Default value:  zeros(dim,1)
%                  - 'tinit':   Possibility 1: Sets the integration time for the first integration.
%                               -> Allowed values: positive scalar
%                               -> Default value:  10000
%                  - 'deltat':  Possibility 1: Sets the integration time for the second integration (starting at the last point of ...
%                               the first integration). The initial value for fsolve is extracted from the trajectory of the second ...
%                               integration. This trajectory is assumed to be close enough to the initial solution at mu0.
%                               -> Allowed values: positive scalar
%                               -> Default value:  15000
%                   - 'dt':     Possibility 1: Sets the integration increment for the second integration. Choose a sufficiently ...
%                               small number to ensure that the trajectory is resolved adequately.
%                               -> Allowed values: positive scalar
%                               -> Default value: 0.1
%                   - 'iv':     Possibility 2: Can be used INSTEAD OF the fields above. 'iv' directly defines the initial value on ...
%                               the manifold edge (without autonomous frequency(s) and continuation parameter), i.e. 'iv' corresponds ...
%                               to the method solution vector s. Ideal for starting from a previously calculated point on the curve. ...
%                               If n_char_iv = numel(iv)/dim does not match the value of the opt_approx_method field "n_char" (or ...
%                               its default value, see below), "iv" is interpolated. 
%                               -> Allowed values: [n_char_iv*dim] (double) array
%                               -> Default value:  (no default value)
% NOTE: It is not necessary to set 'dt' since the default value is used. However, it is demonstrated here in order to show the ...
%       field and a possible value. For usage of the field 'iv', please see section 1.4 of the "Duffing Oscillator" example above.
%                  
% So far we have defined all "options" structures which CoSTAR always needs. Since we want to calculate a quasi-periodic solution ...
% and execute a continuation, we also have to set the "options.opt_approx_method" as well as the "options.opt_cont" structures. The ...
% fields of the "options.opt_approx_method" structure depend on the solution type as well as the chosen approximation method. For ...
% quasi-periodic solutions using the SHM, there are no mandatory fields and two optional fields.
options.opt_approx_method = costaropts('solver','ode45','n_char',50);
% Optional fields: - 'solver':  Sets the the MATLAB-proprietary numerical time integration algorithm. Use specialised solvers for ...
%                               stiff ODEs, e.g. ode15s.
%                               -> Allowed values: 'ode45', 'ode78', 'ode89', 'ode23', 'ode113', 'ode15s', 'ode23s', 'ode23t', 'ode23tb'
%                               -> Default value:  'ode45'
%                  - 'n_char':  Sets the number of characteristic curves which approximate the sought torus function. More ...
%                               characteristics improve the resolution but lead to higher numerical costs. Use a large number for ...
%                               complex manifolds.
%                               -> Allowed values: positive integer
%                               -> Default value:  100
% NOTE: It is not necessary to set 'solver' since the default value is used. However, it is demonstrated here in order to show ...
%       the field and a possible value.
%
options.opt_cont = costaropts('mu_limit',mu_limit);
% Mandatory fields: - 'mu_limit':  Sets the limits of the continuation. For this purpose, we defined the "mu_limit" variable.
% 
% Finally, we are done defining the required settings. All solution type and approximation method specific fields, which are the ...
% fields of "options.opt_init" and "options.opt_approx_method", were explained above. Concerning the rest of the "options" structures ...
% ("options.system", "options.opt_sol", "options.opt_cont" and "options.opt_stability"), only the necessary fields were defined and ...
% explained to some extend.
% If you want to have a deeper insight into the "options" structures and its fields, please use the "costarhelp" function by typing ...
% "costarhelp.options" in the command window. In order to directly open the help pages of particular "options" structures, type ...
% "costarhelp.<name_of_options_structure>", e.g. "costarhelp.opt_cont". In case of "options.opt_init", "options.opt_approx_method" ...
% and "options.opt_stability", type "costarhelp.<name_of_options_structure>('QPS','SHM')" ("QPS": Quasi-Periodic Solution).


%     3.2.3 Calling CoSTAR and running the simulation
%
% Now we can run the computation. This is done by invoking the "costar" function and passing the "options" structure as an input ...
% argument. "costar" returns two objects: 
% - DynamicalSystem object "DYN":  Saves all the information and settings which are contained in "options". It can be used to ...
%                                  restart the computation and it is necessary for postprocessing.
% - Solution object "S": Stores the information that CoSTAR calculated and can further be used for postprocessing.
%
[S,DYN] = costar(options);                          % Calling CoSTAR and performing the continuation
%
% During the computation, CoSTAR displays information in the command window:
% - At the beginning, the iteration process of fsolve trying to find the first point on the curve is shown.
% - As soon as fsolve succeeded, CoSTAR announces "Initial solution found!".
% - After that, CoSTAR displays "Iter: <XXX> -- mu = <XXX> -- stepwidth = <XXX>" when a new point on the curve has been calculated.
%       * "Iter" depicts the number of points on the curve which already have been calculated.
%       * "mu" shows the value of the continuation parameter mu at the latest point on the curve.
%       * "stepwidth" displays the step width that was used to calculate the latest point on the curve.
% - When the step width was adapted, CoSTAR shows the new step width and some additional information. You can ignore it at this point.
% - Finally, CoSTAR reports the reason of termination of the continuation.
%
% Apart from the information in the command window, CoSTAR plots the maximum of the Euclidean norm of the torus function against ...
% the continuation parameter mu. This means that for every computed approximate solution Z(theta_1,theta_2,mu), the Euclidean norm ...
% of (64*64) torus function points is calculated. These points are equidistant distributed on the hyper-time domain. After the ...
% Euclidean norm of all torus function points were computed, the maximum thereof is taken and plotted against mu. This is ...
% essentially a projection of the curve in R^(n+3)-dimensional space into 2D space. Stable solutions are depicted in blue while ...
% unstable solutions are shown in red (attention: if the solution stability is not calculated, the curve is depicted in blue as well!).
%
% Moreover, unstable solutions are depicted in red since we set the field 'stability' of the "options.opt_sol" structure to 'on'. ...
% CoSTAR can also compute bifurcation points, but in this case, there are not any.
% It is pointed out again that details of the computation of stability and bifurcation points are addressed in a separate tutorial ...
% and are therefore not explained here. 


%               3.3  Postprocessing                 %
%
% In order to plot the hyper-time surfaces Z_i(theta_1,theta_2,mu) (torus function components), we need to call the "solplot" ...
% function. Similar to the "costar" function, solplot expects a structure that defines all required options for the plot.
solplot_options_3 = costaropts('zaxis',@(z) z(:,:,1),'space','hypertime','resolution',50,'index',[5,30]);
% Mandatory fields: - 'zaxis':       Defines what is plotted on the vertical axis. "@(z) z(:,:,1)" plots the first component (i = 1) ...
%                                    of the torus function against the hyper-time domain [0, 2*pi]^2.
%                   - 'space':       Specifies the "domain" of the plot. 'hypertime' plots the hyper-time surfaces of the solution.
% Optional fields:  - 'resolution':  Sets the number of points for the plot in each theta-direction.
%                   - 'index':       Defines at which points Z_i(theta_1,theta_2,mu) is plotted, e.g. if index = 25, the solution at ...
%                                    point number 25 (i.e. the 25th point which was calculated) is plotted
%
% Now we can call the "solplot" function. It is a function of the solution class object S, which is why we have to call it by ...
% "S.solplot". Apart from the "opt_solplot" structure, solplot also requires the DynamicalSystem class object DYN. 
% solplot creates the desired plot and additionally returns a structure storing the corresponding z-values, hypertime values and mu-values.
% However, the fields of the output structure depends on the options, so it may change in other cases.
solplot_output_3 = S.solplot(DYN,solplot_options_3);
%
% We do not go into further postprocessing details here as this would exceed the scope of this tutorial.
% Comprehensive explanations of the postprocessing functions can be found in the corresponding tutorials ...
% (Tutorial_Postprocessing_<...>: contplot, solget and solplot) and the associated examples provide short exemplary code. 
% An overview of the available options is given via the costarhelp function by typing "costarhelp.costar" in the command window.


% Finally, we are done with the "Coupled van der Pol Oscillator" example!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  Final Words                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The CoSTAR tutorial on calculating quasi-periodic solutions using the quasi-periodic Shooting Method is now finished.
% For additional information, please use the "costarhelp" function and/or the CoSTAR manual.

% If you are interested in learning about further capabilities of CoSTAR, you are invited to have a look at the other tutorials as well.

% See you soon!