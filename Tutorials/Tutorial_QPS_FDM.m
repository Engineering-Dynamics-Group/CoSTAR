%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                      CoSTAR                       %
%   Continuation of Solution Torus AppRoximations   %
%                                                   %
%                    Tutorial:                      %
%            Quasi-Periodic Solutions               %
%          - Finite Difference Method -             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%           Welcome to the CoSTAR Tutorials!        %
%
% The tutorials comprehensively explain certain CoSTAR modules, which is why they are the perfect starting point for CoSTAR beginners.
% They are highly recommended if you are not yet familiar with the CoSTAR toolbox. 
% 
% If you have already used CoSTAR, you may find the CoSTAR examples helpful.
% These provide example code to briefly show how the toolbox can be set up and how a certain CoSTAR module can be used.
% There is a corresponding example for each tutorial and the code of both of them is identical.
%
% In this tutorial, we will look at how to compute quasi-periodic solutions using the Finite Difference Method (FDM) to approximate ...           
% the solution (associated example: Example_QPS_FDM). We will learn how to set up CoSTAR and how to correctly define all the required ...
% settings on the basis of two different examples:
%
%  1. Continuation of the Duffing oscillator with double external forcing (full non-autonomous system)
%       1.1 Introduction
%       1.2 Continuation of excitation frequency
%           1.2.1 Setting useful variables
%           1.2.2 The CoSTAR settings
%           1.2.3 Calling CoSTAR and running the simulation
%       1.3 Postprocessing: Plot of hyper-time surfaces Z(theta1,theta2,mu)
%       1.4 Change of continuation parameter from excitation frequency to coefficient of nonlinear stiffness
%       ->  FDM specific: - Usage of the "options.opt_init"-fields:
%                               * 'c1_matrix' and 's1_matrix' in section 1.2
%                               * 'fdm_sol' in section 1.4
%                         - Usage of the "options.opt_approx_method"-fields:
%                               * 'n_int_1/2', 'scheme_1/2' and 'approx_order_1/2' in section 1.2
%                               * 'n_int_1/2' and 'points_1/2' in section 1.4
%
%  2. Continuation of Jeffcott(-Laval) rotor (mixed / half-autonomous system)
%       2.1 Introduction
%       2.2 Continuation of rotational speed
%           2.2.1 Setting useful variables
%           2.2.2 The CoSTAR settings
%           2.2.3 Calling CoSTAR and running the simulation
%       2.3 Postprocessing: Plot of hyper-time surfaces Z(theta1,theta2,mu)
%       ->  FDM specific: - Usage of the "options.opt_init"-fields 'c0', 'c1_matrix' and 's1_matrix'
%                         - Usage of the "options.opt_approx_method"-fields 'n_int_1/2', 'scheme_1/2' and 'approx_order_1/2'
%
%  3. Continuation of two coupled van der Pol oscillators (full autonomous system)
%       3.1 Introduction
%       3.2 Continuation of nonlinear damping
%           3.2.1 Setting useful variables
%           3.2.2 The CoSTAR settings
%           3.2.3 Calling CoSTAR and running the simulation
%       3.3 Postprocessing: Plot of hyper-time surfaces Z(theta1,theta2,mu)
%       ->  FDM specific: - Usage of the "options.opt_init"-fields 'c1_matrix' and 's1_matrix'
%                         - Usage of the "options.opt_approx_method"-fields 'n_int_1/2' and 'points_1/2'
%
% NOTE: All examples can be worked through independently.
%
% IMPORTANT: Explanations can be found at the beginning of new lines as well as right next to code, so make sure that you do not ...
%            miss some helpful comments!
%            Furthermore, it is advised to execute the code line by line or in blocks when going through this tutorial and do not ...
%            execute the complete script by clicking "Run" or pressing "F5". To do that, you can select the desired lines of code ...
%            to be executed and press "F9" or you can click right on the selected code and choose "Evaluate Selection in Command ...
%            Window". This should help to better understand what is going on and how CoSTAR works. 
%
% Alright, let's clean our "desk" and let's get started!
clear variables; clc; close all;                                        % clear workspace; clear command window; close all figures

% We need to add the main CoSTAR folder (and all subfolders) to MATLAB's search path. 
% Assuming you are running this script within the "Tutorials" subfolder of CoSTAR, this is done by:
% addpath(genpath('..\'))                                               % genpath() generates a search path containing all subfolders
% (The command is set as comment in order to prevent unwanted folders to be added to MATLAB's search path.)



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%        Example No. 1: Duffing Oscillator        %%
%             Full Non-Autonomous System            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%               1.1  Introduction                   %
%
% The first example we have a look on features the Duffing equation with double external forcing. The dimensionless form of the ...
% equation reads:     x'' + 2*D*x' + x + kappa*x^3 = f1*sin(eta*tau) + f2*sin(ratio*eta*tau)     (1)
% where x is the deflection, D is the damping factor, kappa is the coefficient of the nonlinear stiffness, f1 and f2 are the 
% amplitudes of the excitation, eta is the dimensionless excitation frequency and tau is the dimensionless time. Following that, ...
% x' = dx/dtau and x'' = dx'/dtau holds. For a quasi-periodic solution to appear, the ratio of the excitation frequencies eta and ...
% ratio*eta must be irrational, which is ensured by the variable ratio.
% CoSTAR always needs the equation to be of the form dz/dt = f(t,z,param) (param represents all additional parameters), which is ...
% why we have to transform (1) into a system of two differential equations of first order. To do that, we introduce the state ...
% variable vector z = [z1; z2] = [x; x'], leading to:
% dz/dtau = f(tau,z,D,kappa,f1,f2,eta,ratio)  (2)  <=>  z1' = z2
%                                                       z2' = -2*D*z2 - z1 - kappa*z1^3 + f1*sin(eta*tau) + f2*sin(ratio*eta*tau)
%
% Our aim is to approximate the quasi-periodic solution of equation (2) z(tau) for eta in the range of [0.8, 2] using the FDM. ...
% Instead of the quasi-periodic solution itself, we calculate the (image of the) torus function Z = Z(theta_1,theta_2) that ...
% describes the torus on which the quasi-periodic solution evolves, using the hyper-time invariance equation:
% dZ/dtheta_1 * Omega_1 + dZ/dtheta_2 * Omega_2 = f(Z,theta_1,theta_2,param)   (3),
% where Omega_1 = eta and Omega_2 = ratio*eta are the excitation frequencies and where f is the right-hand side of (2). This ...
% problem can be rewritten into finding the zero set of the function g: R^(n+1) -> R^n with g = 0 and for eta in [0.8, 2], which ...
% defines a curve in (n+1)-dimensional space (n depends on the dimension of the system as well as the finite difference ...
% discretisation). Hence, a solution Z(theta_1,theta_2) is also denoted as a "point on the curve" in the following explanations. ...
% CoSTAR will approximate discrete points on this curve by executing a path continuation. As the frequency eta is varied, the ...
% continuation parameter is mu = eta. The remaining parameters are set to:
D = 0.05;            kappa = 1.5;
f1 = 0.25;           f2 = 0.25;
ratio = sqrt(2);


%     1.2 Continuation of excitation frequency      %
%
%          1.2.1 Setting useful variables           
%
% Before we specify the settings needed by CoSTAR, we introduce some important variables, which we will use later on. This is not ...
% necessarily needed but it helps to keep an overview of the most important variables/settings. Furthermore, important aspects of ...
% CoSTAR are explained here, making the following section "1.2.2 The CoSTAR settings" clearer.
mu_limit = [0.8, 2];                    % mu_limits = eta_limits = [0.8, 2] sets the upper and bottom limit of our continuation.
%
eta0 = mu_limit(1);                     % eta0 defines the eta-value at which the continuation begins.
%
Fcn =  @(t,z,param) duffing_ap_qp(t,z,param);   % Fcn is a function handle containing the right-hand side (RHS) of equation (2). 
% You may have noticed that Fcn is a function of t, z and param, whereas the right-hand side of (2) is a function of tau, z, ...
% D, kappa, f1, f2, eta and ratio. This is because CoSTAR ALWAYS requires the definition of Fcn as "Fcn = @(t,z,param) ..." when ...
% calculating quasi-periodic solutions. param is a cell array storing all parameters, apart from t and z, that need to be passed ...
% to (2). The time t as well as the state variable vector z are always treated separately and therefore not included in param. ...
% Here, we need to define param since we need to pass the parameters D, kappa, f1, f2, eta and ratio to Fcn. The name of the ...
% "time argument" being t (and not tau) is required by CoSTAR. It is equal to our dimensionless time tau.
%
% TASK: Open the function "duffing_ap_qp" (click the right mouse button right on it and choose 'Open "duffing_ap_qp"' or go into ...
%       the "RHS" subfolder located in the main path of CoSTAR and double click on the function). Have a look at how the equation ...
%       is defined and compare that to our system right next to equation (2).
% IMPORTANT: Please pay attention to how the state variables z1 and z2 are defined and how the parameters D, kappa, f1, f2, eta ...
%            and ratio are extracted from param. Moreover, pay attention to the definition and explanation of the time variables ...
%            t1 and t2, which is especially important when dealing with quasi-periodic solutions of forced systems.
%
% Now we define the "param" array. It is important that this is a cell array AND the order of the parameters placed in param must ...
% correspond to the definitions in the "duffing_ap_qp" function! For example, kappa is defined by kappa = param{2} in the ...
% "duffing_ap_qp" function. Therefore, kappa has to be the SECOND variable in the "param" array. For the variable eta, we use eta0 ...
% since the continuation starts at the eta-value of eta0.
param = {D, kappa, f1, f2, eta0, ratio};   
% Next, we have to tell CoSTAR where the continuation parameter is located within param. We also call this the "active parameter". ...
% This is done by defining an integer variable which is used to get the continuation parameter from param by cell indexing, i.e. ...
% continuation parameter mu = param{active_parameter}. As we want to continue the curve via eta and the corresponding value eta0 ...
% is the FIFTH element of param, we set:
active_parameter = 5;
%
% Going on, we need to set the non-autonomous frequency(s) of the external forcing (eta). This sounds a bit confusing since eta is ...
% the continuation parameter mu and we already set the range of the continuation by defining mu_limit. So why do we need to specify ...
% the non-autonomous frequency(s) again? The reason is that eta CAN be the continuation parameter but does NOT HAVE TO BE the ...
% continuation parameter. In order to deal with this uncertainty, we introduce the variable "non_auto_freq" which sets the ...
% non-autonomous frequency(s). In this case, there are two excitation frequencies Omega_1 = eta and Omega_2 = ratio*eta, which are ...
% stored in the [1x2]-array [eta, ratio*eta]. Since eta is the continuation parameter (eta = mu), the excitation frequencies depend ...
% on mu. This is why we have to set "non_auto_freq" as function handle @(mu), resulting in:
non_auto_freq = @(mu) [mu, ratio*mu];
% "non_auto_freq" ALWAYS has to be a function handle @(mu) if it depends on mu. This also allows a great flexibility since the ...
% non-autonomous frequencies can be an arbitrary function of mu, e.g. @(mu) 10.*[mu, ratio*mu]. In the case that BOTH of the ...
% non-autonomous frequencies are independent from mu and therefore constant throughout the continuation (i.e. another parameter ...
% is the continuation parameter), we can define "non_auto_freq" either as double (e.g. non_auto_freq = [1.5, ratio*1.5]) or as ...
% function handle (e.g. non_auto_freq = @(mu) [1.5, ratio*1.5]).
%
% Last but not least, we set variables which are used to create an initial value (IV) where the nonlinear system solver fsolve ...
% starts to find the first approximate solution of equation (3) at mu0 (i.e. the first point on the curve), referred to as ...
% Z0 = Z(theta_1,theta_2,mu0). Using finite differences, the initial value is created via a first order multi-dimensional Fourier ...
% series:
% Z_IV(theta_1,theta_2) = C0 + C1_1*cos(theta_1) + C1_2*cos(theta_2) + C1_12*cos(theta_1 + theta_2) + ...
%                            + S1_1*sin(theta_1) + S1_2*sin(theta_2) + S1_12*sin(theta_1 + theta_2)
% All coefficients can be set by the user. They have to be column vectors of dimension dim and their default value is the zero ...
% vector. The coefficients are stored in the matrices C1_mat = [C1_1, C1_2, C1_12] and S1_mat = [S1_1, S1_2, S1_12]. It is ...
% important to note that the better Z_IV matches the approximate solution Z0, the faster fsolve converges towards Z0. If Z_IV is ...
% too far away from Z0 and/or the discretisation is too coarse, it may happen that fsolve does not converge at all! In general, it ...
% can be quite challenging to find suitable values for the parameters of the initial value. For our Duffing example, we use ...
% S1_1 = S1_2 = [0.5; 0] and C1_1 = C1_2 = [0; 0.4] (all other coefficients remain zero), so we set:
C1_mat = [ 0,   0,  0;          % Since C1_12 = [0; 0], the third column can be omitted.
          0.4, 0.4, 0];
S1_mat = [0.5, 0.5, 0;          % Since S1_12 = [0; 0], the third column can be omitted.
           0,   0,  0];


%            1.2.2 The CoSTAR settings              
%
% All information and settings which CoSTAR needs are defined in a structure array called "options". 
% The structure "options" itself consists of structure arrays that define important parameters used by different modules of CoSTAR.
% 
% CoSTAR ALWAYS needs the following "option" structures: "options.system", "options.opt_sol" and "options.opt_init".
% Depending on the system and problem, CoSTAR might need some or all of the following "option" structures additionally: 
% "options.opt_approx_method":  Required when calculating (quasi-) periodic solutions.
% "options.opt_cont":           Required when running a continuation.
% "options.opt_stability":      Optional when calculating the stability of solutions.
% In this case, "options.opt_approx_method" and "options.opt_cont" are additionally needed.
% 
% Each of the "option" structures contain mandatory fields which ALWAYS have to be set. 
% Furthermore, there are optional fields that CAN be set. Most of the optional fields have a default value. 
% However, even optional fields NEED to be set in some cases (denoted as "Opt-Need.", e.g. 'param' in this example, see below).
% 
% IMPORTANT: All option structures must be created by the "costaropts" function. The syntax of the arguments of "costaropts" is ...
%            equivalent to the MATLAB struct function, i.e. costaropts(fieldname1,value1,...,fieldnameN,valueN).
%
% Let us start with the "options.system" structure. There are three mandatory fields, one optional-needed field (as in most cases) ...
% and one optional field:
options.system = costaropts('order',1,'dim',2,'rhs',Fcn,'param',param,'info','Continuation of Quasi-Periodic Duffing Equation');
% Mandatory fields: - 'order':  Describes the order of the ODE. As CoSTAR takes a system of differential equations of first order ...
%                               ( dz/dt = f(t,z,param) ), the order is 1.
%                   - 'dim':    Dimension of the state space. In this case, the dimension of the state variable vector z is 2.
%                               -> Allowed values: positive integer (scalar)
%                   - 'rhs':    Right-hand side of equation (2), which we already assigned to the variable Fcn.   
%                               -> Allowed values: function handle @(t,z,param)
% Opt-Need. field:  - 'param':  This field expects the previously defined "param" array. We NEED to set it because it is required ...
%                               by Fcn. Moreover, when executing a continuation, param is always necessary. However, param CAN be ...
%                               omitted when only calculating the initial solution (i.e. no continuation is carried out).
%                               -> Allowed values: [1xp] cell array, where p is the number of parameters for the RHS apart from t and z.
% Optional field:   - 'info':   Contains your individual text about the computation. This does not need to be set. However, it may ...
%                               help you later if you have forgotten what this computation is about (default: no text).
%                               -> Allowed values: char or string
%
% Next, there is the "options.opt_sol" structure. There are three mandatory fields and a total of four optional-needed fields. ...
% However, we only need three of the optional-needed fields because the system is fully non-autonomous. The remaining optional-needed ...
% field ('auto_freq') is needed when the system exhibits autonomous frequency(s). Apart from that, there are two optional ...
% fields, but we use their default values and therefore do not set them.
options.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','finite-difference','cont','on','stability','off', ...
                             'non_auto_freq',non_auto_freq,'act_param',active_parameter);
% Mandatory fields: - 'sol_type':       We need to specify what type of solution CoSTAR has to calculate. For quasi-periodic ...
%                                       solutions, the key is 'quasiperiodic' or 'qps'.
%                   - 'cont':           As we want to execute a continuation, we set 'cont' = 'on'. If 'cont' = 'off', CoSTAR would ...
%                                       only calculate the initial solution z(tau,mu0).
%                   - 'stability':      CoSTAR computes the stability of the solution if 'stability' = 'on'. However, stability ...
%                                       calculation is not yet available for QPS when using the FDM, so we have to set it to 'off'.
% Opt-Need. field:  - 'approx_method':  Defines the approximation method used to calculate approximate solutions of equation (3). ...
%                                       For the FDM, the key is 'finite-difference' or 'fdm'.
%                   - 'non_auto_freq':  Function handle setting the non-autonomous frequency of the system. 'non_auto_freq' must ...
%                                       be set if the system exhibits excitation frequency(s) and is not allowed otherwise.
%                                       -> Allowed values: [1x2] double or function handle @(mu) array with ...
%                                                          values >= 'freq_limit' (see below)
%                                       -> Default value:  (no default value)
%                   - 'act_param':      As we want to do a continuation, we have to tell CoSTAR where the continuation parameter is ...
%                                       located within param. To do that, we use the previously defined variable "active_parameter". ... 
%                                       Here, this field NEEDS to be set, because we provided a "param" array. If there is no ...
%                                       "param" array, 'act_param' may not be set.
%                                       -> Allowed values: positive integer (scalar) <= length(options.system.param)
%                                       -> Default value:  (no default value)
% Optional fields:  - 'freq_limit':     Defines the bottom limit of allowed base frequency values (frequency limit) of a solution. ...
%                                       CoSTAR stops if any base frequency falls below the limit. 
%                                       -> Allowed values: positive double (scalar)
%                                       -> Default value:  1e-4
%                   - 'display':        Controls the command window output.
%                                       -> Allowed values: 
%                                           - 'off':   Only warnings and errors are displayed.
%                                           - 'final': The latest solution and the termination message are displayed.
%                                           - 'iter':  Displays the iteration process of the initial solution, the latest five ...
%                                                      solutions during continuation and the termination message.
%                                           - 'iter-detailed': Similar to 'iter', but all computed solutions are displayed.
%                                           - 'step-control':  Similar to 'iter-detailed', but with additional step control ...
%                                                              information (if enabled).
%                                           - 'error-control': Similar to 'iter-detailed', but with additional error control ...
%                                                              information (if enabled).
%                                           - 'full':  All possible information are displayed. This is similar to the log file.
%                                       -> Default value: 'iter'
%
% Going on, we have to set the "options.opt_init" structure. The fields of the "options.opt_init" structure depend on the solution ...
% type as well as the chosen approximation method. For quasi-periodic solutions using the FDM, there are no mandatory fields and ...
% four optional fields, of which a maximum of 3 may be used. It is not allowed to use 'fdm_sol' in combination with 'c0', 'c1' or 's1'.
options.opt_init = costaropts('c1_matrix',C1_mat,'s1_matrix',S1_mat);
% Optional fields: - 'c0':         Sets the Fourier series coefficient of the constant term used to create an initial value for fsolve ...
%                                  to find the first approximate solution Z0. We do not need 'c0' here so we do not specify it.
%                                  -> Allowed values: [dim x 1] (double) array
%                                  -> Default value:  zeros(dim,1)
%                  - 'c1_matrix':  Sets the Fourier series coefficients of all three "cos" terms used to create an initial value for ...
%                                  fsolve to find the first approximate solution Z0. We already defined C1_mat above.
%                                  -> Allowed values: [dim x 1], [dim x 2] or [dim x 3] (double) array
%                                  -> Default value:  zeros(dim,3)
%                  - 's1_matrix':  Sets the Fourier series coefficients of all three "sin" terms used to create an initial value for ...
%                                  fsolve to find the first approximate solution Z0. We already defined S1_mat above.
%                                  -> Allowed values: [dim x 1], [dim x 2] or [dim x 3] (double) array
%                                  -> Default value:  zeros(dim,3)
%                   - 'fdm_sol':   The initial value can be taken from an already calculated solution. 'fdm_sol' takes the method ...
%                                  solution vector s (stored in Solution_object.s). If the number of intervals 'n_int_1' and ...
%                                  'n_int_2', defined in opt_approx_method (or its default values, see below), do not match the ...
%                                  number of intervals of 'fdm_sol', the provided solution is interpolated. In this case, the ...
%                                  number of intervals of 'fdm_sol' must be defined via the fields 'n_int_1_fdm_sol' and ... 
%                                  'n_int_2_fdm_sol' (see below). Moreover, the fields 'c0', 'c1' and 's1' are not allowed when ...
%                                  providing 'fdm_sol'.
%                                  -> Allowed values [dim*n_int_1_fdm_sol*n_int_2_fdm_sol x 1] (double) array
%                                  -> Default value: (no default value)
%                   - 'n_int_1_fdm_sol':  This field can be used to define the number of intervals n_int_1 of 'fdm_sol' if this ...
%                                         number does not match 'n_int_1' defined in opt_approx_method (or the default value of ...
%                                         n_int_1, see below).  Thus, this field is only allowed when using the field 'fdm_sol'.
%                                         -> Allowed values Positive integer >= 2
%                                         -> Default value: n_int_1 (see below)
%                   - 'n_int_2_fdm_sol':  This field can be used to define the number of intervals n_int_2 of 'fdm_sol' if this ...
%                                         number does not match 'n_int_2' defined in opt_approx_method (or the default value of ...
%                                         n_int_2, see below). Thus, this field is only allowed when using the field 'fdm_sol'.
%                                         -> Allowed values Positive integer >= 2
%                                         -> Default value: n_int_2 (see below)
% NOTE: For usage of the field 'fdm_sol', please see section 1.4.
%                  
% So far we have defined all "options" structures which CoSTAR always needs. Since we want to calculate a quasi-periodic solution ...
% and execute a continuation, we also have to set the "options.opt_approx_method" as well as the "options.opt_cont" structures. The ...
% fields of the "options.opt_approx_method" structure depend on the solution type as well as the chosen approximation method. For ...
% quasi-periodic solutions using the FDM, there are no mandatory fields and eight optional fields of which a maximum of six may be used.
options.opt_approx_method = costaropts('n_int_1',25,'scheme_1','central','approx_order_1',6,...
                                       'n_int_2',25,'scheme_2','central','approx_order_2',6);
% Optional fields: - 'n_int_1':         Sets the number of intervals into which the hyper-time domain is divided in theta_1- ...
%                                       direction. This means that the hyper-time domain is approximated by (n_int_1+1) points in ...
%                                       the range of theta_1 = [0, 2*pi]. n_int_1 and n_int_2 define the resolution of the FD grid.
%                                       -> Allowed values: Positive integer >= 2
%                                       -> Default value:  50
%                  - 'scheme_1':        This field refers to the discretisation scheme used to approximate the derivation dZ/dtheta_1.
%                                       -> Allowed values: 'central', 'forward', 'backward'
%                                       -> Default value:  'central'
%                  - 'approx_order_1':  Defines the order of approximation of dZ/dtheta_1.
%                                       -> Allowed values: Positive integer. Must be even number if 'scheme' = 'central'
%                                       -> Default value:  6
%                  - 'points_1':        Specifies the local grid points which are used to approximate dZ/dtheta_1. E.g.: If 'points' ...
%                                       is set to [-1,0,1], dZ/dtheta_1 at grid point index (i,j) is approximated by the torus ...
%                                       function values at (i-1,j), (i+0,j) and (i+1,j). Can be used INSTEAD OF 'scheme_1' and ...
%                                       'approx_order_1', i.e. 'points_1' is not allowed when specifying 'scheme_1' and/or ...
%                                       'approx_order_1' and vice versa.
%                                       -> Allowed values: Integer vector
%                                       -> Default value:  [-3,-2,-1,0,1,2,3]
%                   - The meaning of all fields with index "_2" is almost identical to the corresponding fields with index "_1", ...
%                     but they refer to the discretisation in theta_2-direction (instead of theta_1-direction).
% NOTE: It is not necessary to set 'scheme_1/2' and 'approx_order_1/2' since the default values are used. However, it is ...
%       demonstrated here in order to show the fields and possible values. For usage of the fields 'points_1/2', please see ...
%       section 1.4 or section 3.2 of the "Coupled van der Pol Oscillator" example below.
%
options.opt_cont = costaropts('mu_limit',mu_limit,'step_width',0.5,'pred','secant');
% Mandatory fields: - 'mu_limit':    Sets the limits of the continuation. For this purpose, we defined the "mu_limit" variable.
%                                    -> Allowed values: [1x2] double array of increasing numerical values
% Optional fields:  - 'step_width':  Defines the initial step width (default: 0.1). The step width will be altered in the range ...
%                                    of step_width*[0.2, 5]. It is set here in order to reduce the numerical effort. Step control ...
%                                    is explained in a separate tutorial in detail.
%                   - 'pred':        Defines the method to calculate the predictor point (default: tangent). When calculating ...
%                                    quasi-periodic solutions using the FDM, is is HIGHLY advised to use the secant predictor since ...
%                                    the calculation of the local tangent requires a huge numerical effort. 
%
% Finally, we are done defining the required settings. All solution type and approximation method specific fields, which are the ...
% fields of "options.opt_init" and "options.opt_approx_method", were explained above. Concerning the rest of the "options" structures ...
% ("options.system", "options.opt_sol" and "options.opt_cont"), only the necessary fields were defined and explained to some extend.
% If you want to have a deeper insight into the "options" structures and its fields, please use the "costarhelp" function by typing ...
% "costarhelp.options" in the command window. In order to directly open the help pages of particular "options" structures, type ...
% "costarhelp.<name_of_options_structure>", e.g. "costarhelp.opt_cont". In case of "options.opt_init" and "options.opt_approx_method", ...
% type "costarhelp.<name_of_options_structure>('QPS','FDM')" ("QPS": Quasi-Periodic Solution).


%     1.2.3 Calling CoSTAR and running the simulation
%
% Now we can run the computation. This is done by invoking the "costar" function and passing the "options" structure as an input ...
% argument. "costar" returns two objects: 
% - DynamicalSystem object "DYN":  Saves all the information and settings which are contained in "options". It can be used to ...
%                                  restart the computation and it is necessary for postprocessing.
% - Solution object "S": Stores the information that CoSTAR calculated and can further be used for postprocessing.
%
[S,DYN] = costar(options);                          % CoSTAR is called by costar(options).
%
% During the computation, CoSTAR displays information in the command window:
% - At the beginning, the iteration process of fsolve trying to find the first point on the curve is shown.
% - As soon as fsolve succeeded, CoSTAR announces "Initial solution found!". ...
%   If the stability of a solution is additionally computed, the message is supplemented by the information (stable) or (unstable).
% - After that, the continuation starts and CoSTAR displays "Iter: <XXX> -- mu = <XXX> -- stepwidth = <XXX>" for the latest five ...
%   computed solutions.
%       * "Iter: <XXX>" depicts the number of the computed point on the curve. Please keep in mind that the initial solution is ...
%          counted as Iter = 1.
%       * "mu = <XXX>" shows the value of the continuation parameter mu for the related point on the curve.
%       * "stepwidth = <XXX>" displays the step width that was used to compute the point on the curve.
%       * "(un)stable" reports whether the solution is stable or unstable if the stability was computed.
% - Finally, CoSTAR reports the reason of termination of the continuation.
% 
% Please note that the command window output described above is the default output and it may change if the options.opt_sol field ...
% 'display' is manually set.
% 
% Furthermore, a log file named "CoSTAR_Log_ID_yyyy-mm-dd_hh.mm.ss.txt" (yyyy-mm-dd and hh.mm.ss show the date and time of day ...
% when the computation started) is created in the current directory of MATLAB, giving a more in-depth view of the computation.


%                1.3 Postprocessing                 %
%
% As you have probably noticed, CoSTAR automatically creates a diagram as well. By default, the maximum of the Euclidean norm of ...
% the torus function against the continuation parameter mu. This means that for every computed approximate solution ...
% Z(theta_1,theta_2,mu), the Euclidean norm of (50*50) torus function points is calculated. These points are equidistant distributed ...
% on the hyper-time domain. After the Euclidean norm of all torus function points were computed, the maximum thereof is taken and ...
% plotted against mu. This can be understood as a mapping of the computed curve in R^(n+1)-dimensional space into 2D space. ...
% The line is displayed in blue since the stability was not computed.
%
% In order to plot the hyper-time surfaces Z_i(theta_1,theta_2,mu) (torus function components), we need to call the "solplot" ...
% function. Similar to the "costar" function, solplot expects a structure that defines all required options for the plot.
solplot_options_1 = costaropts('zaxis',@(z) z(:,:,1),'space','hypertime','resolution',25,'index',[25,200]);
% Mandatory fields: - 'zaxis':       Defines what is plotted on the vertical axis. "@(z) z(:,:,1)" plots the first component (i = 1) ...
%                                    of the torus function against the hyper-time domain [0, 2*pi]^2.
%                   - 'space':       Specifies the "domain" of the plot. 'hypertime' plots the hyper-time surfaces of the solution.
% Optional fields:  - 'resolution':  Sets the number of points for the plot in each theta-direction.
%                   - 'index':       Defines at which points Z_i(theta_1,theta_2,mu) is plotted, e.g. if index = 25, the solution at ...
%                                    point number 25 (i.e. the 25th point which was calculated) is plotted
%
% Now we can call the "solplot" function. It is a function of the solution class object S, which is why we have to call it by ...
% "S.solplot". Apart from the "opt_solplot" structure, solplot also requires the DynamicalSystem class object DYN. 
% solplot creates the desired plot and additionally returns a structure storing the corresponding z-values, hypertime values and mu-values.
% However, the fields of the output structure depends on the options, so it may change in other cases.
solplot_output_1 = S.solplot(DYN,solplot_options_1);
%
% We do not go into further postprocessing details here as this would exceed the scope of this tutorial.
% Comprehensive explanations of the postprocessing functions can be found in the corresponding tutorials ...
% (Tutorial_Postprocessing_<...>: contplot, solget and solplot) and the associated examples provide short exemplary code. 
% An overview of the available options is given via the costarhelp function by typing "costarhelp.costar" in the command window.


%      1.4 Change of the continuation parameter      %
%
% In the example explained above, the continuation parameter was the excitation frequency eta. How does the "options" structure need ...
% to be modified if we want to vary a different parameter, let's say the coefficient of the nonlinear stiffness kappa?
% Think about it before you continue with this tutorial! If you are not sure which parameters or in what sense parameters need to ...
% be adjusted, please scroll up and read the section "1.2.1 Setting useful variables" again.
%
% First of all, we define new limits for the continuation and set the starting value kappa0:
mu_limit_kappa = [1, 2];
kappa0 = mu_limit_kappa(1);
% We do not change the values of the other parameters (D = 0.05, f1 = f2 = 0.25, ratio = sqrt(2)). Of course, the function ...
% handle Fcn also remains.
% In contrast to the continuation above, we need to fix the excitation frequency eta since CoSTAR accepts only one continuation ...
% parameter, which is kappa in this case. We set
eta_kappa = 1.5;
% Furthermore, we need to define a new function handle "non_auto_freq_kappa" using eta_kappa:
non_auto_freq_kappa = @(mu) [eta_kappa, ratio*eta_kappa];
% Now we can define a new "param" array and set the active parameter:
param_kappa = {D, kappa0, f1, f2, eta_kappa, ratio};   
active_parameter_kappa = 2;
% Instead of the Fourier series coefficients 'c1_mat' and 's1_mat', we use 'fdm_sol' this time. For 'fdm_sol', we take the 142th ...
% solution point of the continuation above, which is the 142th column of the field 's' of the solution object S (we use the 142th ...
% solution since we set eta_kappa = 1.5).
% Furthermore, we set 'n_int_1' = 'n_int_2' = 30, so FDM_sol is interpolated to adapt it to the new number of intervals.
% Therefore, we need the opt_init fields 'n_int_2_fdm_sol' and 'n_int_2_fdm_sol' to define the number of intervals of FDM_sol.
FDM_sol = S.s(:,142);
%
options_kappa.system = costaropts('order',1,'dim',2,'rhs',Fcn,'param',param_kappa,'info','Continuation of Quasi-Periodic Duffing Equation - kappa');
options_kappa.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','finite-difference','cont','on','stability','off', ...
                                   'non_auto_freq',non_auto_freq_kappa,'act_param',active_parameter_kappa);
options_kappa.opt_init = costaropts('fdm_sol',FDM_sol,'n_int_1_fdm_sol',25,'n_int_2_fdm_sol',25);
options_kappa.opt_approx_method = costaropts('n_int_1',30,'points_1',[-3,-2,-1,0,1,2,3],...   % The fields 'points_1/2' are used ...
                                             'n_int_2',30,'points_2',[-3,-2,-1,0,1,2,3]);     % (default values, only for demonstration).
options_kappa.opt_cont = costaropts('mu_limit',mu_limit_kappa,'step_width',0.1,'pred','secant');
%
[S_kappa,DYN_kappa] = costar(options_kappa); 
%
% That's it! Now you also know how to set up CoSTAR if the excitation frequency is not the continuation parameter.
%
% Additional question (optional): Compare the last continuation plot of section 1.4 with the continuation plot of section 1.4 of ...
%                                 the QPS-FGM-Tutorial (pay attention to the vertical axis). Why are they not identical even though ...
%                                 the same parameters are used? Hint: The different accuracies of the FGM and FDM are not the reason!
%                                 Answer can be found to the right ->                                                                                   The continuation plot of section 1.2 reveals three different solutions for eta = 1.5. ...
%                                                                                                                                                       In the QPS-FGM-Tutorial, fsolve converges towards the bottom solution, while fsolve ...
%                                                                                                                                                       converges towards the upper solution in this tutorial.

% Finally, we are done with the "Duffing Oscillator" example!
% Going on, we will learn how to deal with mixed systems exhibiting one excitation frequency and one autonomous frequency on the ...
% basis of the Jeffcott(-Laval) rotor.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%      Example No. 2: Jeffcott(-Laval) Rotor      %%
%          Mixed / Half-Autonomous System           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
clear variables; clc; close all;                    % Let's clean our "desk" before we begin with our second example.

%               2.1  Introduction                   %
%
% After having discussed a non-autonomous system with two excitation frequencies, we will turn to "mixed" systems exhibiting ...
% external forcing as well as self excitation. As an example, we take a Jeffcott(-Laval) rotor with external and internal damping, ...
% gravitational influence and nonlinear cubic damping forces. The second-order ODE reads:
%       x'' + 2*Di*(1+delta)*x' + d3*(x')^3 + x - 2*Di*eta*y = e*(eta^2)*sin(eta*tau)           (4.1)
%       y'' + 2*Di*(1+delta)*y' + d3*(y')^3 + y + 2*Di*eta*x = e*(eta^2)*cos(eta*tau) - Fg      (4.2)
% where x and y are the coordinates of the deflection, Di is the factor of internal damping, delta is the ratio of external to ...
% internal damping, d3 is the coefficient of the nonlinear damping, eta is the dimensionless rotational speed, e is the ...
% eccentricity and tau is the dimensionless time. Following that, x' = dx/dtau and x'' = dx'/dtau holds. CoSTAR always needs the ...
% equation to be of the form dz/dt = f(t,z,param) (param represents all additional parameters), which is why we have to transform ...
% (4) into a system of four differential equations of first order. To do that, we introduce the state variable vector ...
% z = [z1; z2; z3; z4] = [x; y; x'; y'], leading to:
% dz/dtau = f(tau,z,eta,Di,delta,e,d3,Fg)  (5)  
%                              <=>  z1' = z3
%                                   z2' = z4
%                                   z3' = - 2*Di*(1+delta)*z3 - d3*z3^3 - z1 + 2*Di*eta*z2 + e*(eta^2)*sin(eta*tau);
%                                   z4' = - 2*Di*(1+delta)*z4 - d3*z4^3 - z2 - 2*Di*eta*z1 + e*(eta^2)*cos(eta*tau) - Fg;
%
% The system exhibits a quasi-periodic solution z(tau) for eta in the range of [1.72, 2.5] (and the parameters defined as below), ...
% which we want to approximate using the FDM. Instead of the quasi-periodic solution itself, we calculate the (image of the) torus ...
% function Z = Z(theta_1,theta_2) that describes the torus on which the quasi-periodic solution evolves, using the hyper-time ...
% invariance equation:
% dZ/dtheta_1 * Omega_1 + dZ/dtheta_2 * omega_2 = f(Z,theta_1,theta_2,param)   (6),
% where Omega_1 = eta is the excitation frequency, omega_2 is the unknown autonomous frequency and f is the right-hand side of (5).
% This problem can be rewritten into finding the zero set of the function g: R^(n+2) -> R^(n+1) with g = 0 and for eta in [1.72, 2.5], ...
% which defines a curve in (n+2)-dimensional space (n depends on the dimension of the system as well as the finite difference ...
% discretisation). Hence, a solution Z(theta_1,theta_2) is also denoted as a "point on the curve" in the following explanations. ...
% CoSTAR will approximate discrete points on this curve by executing a path continuation. As the frequency eta is varied, the ...
% continuation parameter is mu = eta. The remaining parameters are set to:
Di = 0.2;       delta = 1/3;        d3 = 0.25;
e = 0.25;       Fg = 0.3924; 


%       2.2 Continuation of rotational speed        %
%
%          2.2.1 Setting useful variables           
%
% Before we specify the settings needed by CoSTAR, we introduce some important variables, which we will use later on. This is not ...
% necessarily needed but it helps to keep an overview of the most important variables/settings. Furthermore, important aspects of ...
% CoSTAR are explained here, making the following section "2.2.2 The CoSTAR settings" clearer.
mu_limit = [1.72, 2.5];                 % mu_limits = eta_limits = [1.72, 2.5] sets the upper and bottom limit of our continuation.
%
eta0 = mu_limit(2);                     % eta0 defines the eta-value at which the continuation begins. We start at the upper limit.
%
Fcn =  @(t,z,param) laval_qp(t,z,param);    % Fcn is a function handle containing the right-hand side (RHS) of equation (5). 
% You may have noticed that Fcn is a function of t, z and param, whereas the right-hand side of (5) is a function of tau, z, ...
% eta, Di, delta, e, d3 and Fg. This is because CoSTAR ALWAYS requires the definition of Fcn as "Fcn = @(t,z,param) ..." when ...
% calculating quasi-periodic solutions. param is a cell array storing all parameters, apart from t and z, that need to be passed ...
% to (5). The time t as well as the state variable vector z are always treated separately and therefore not included in param. ...
% Here, we need to define param since we need to pass the parameters eta, Di, delta, e, d3 and Fg to Fcn. The name of the ...
% "time argument" being t (and not tau) is required by CoSTAR. It is equal to our dimensionless time tau.
%
% TASK: Open the function "laval_qp" (click the right mouse button right on it and choose 'Open "laval_qp"' or go into ...
%       the "RHS" subfolder located in the main path of CoSTAR and double click on the function). Have a look at how the equation ...
%       is defined and compare that to our system directly below of equation (5).
% IMPORTANT: Please pay attention to how the state variables z1, z2, z3 and z4 are defined and how the parameters eta, Di, delta, ...
%            e, d3 and Fg are extracted from param. Moreover, pay attention to the definition and explanation of the time variables ...
%            t1 and t2, which is especially important when dealing with quasi-periodic solutions of forced systems.
%
% Now we define the "param" array. It is important that this is a cell array AND the order of the parameters placed in param must ...
% correspond to the definitions in the "laval_qp" function! For example, Di is defined by Di = param{2} in the "laval_qp" function. ...
% Therefore, Di has to be the SECOND variable in the "param" array. For the variable eta, we use eta0 since the continuation starts ...
% at the eta-value of eta0.
param = {eta0, Di, delta, e, d3, Fg};
% Next, we have to tell CoSTAR where the continuation parameter is located within param. We also call this the "active parameter". ...
% This is done by defining an integer variable which is used to get the continuation parameter from param by cell indexing, i.e. ...
% continuation parameter mu = param{active_parameter}. As we want to continue the curve via eta and the corresponding value eta0 ...
% is the FIRST element of param, we set:
active_parameter = 1;
%
% Going on, we need to set the non-autonomous frequency of the external forcing (eta). This sounds a bit confusing since eta is the ...
% continuation parameter mu and we already set the range of the continuation by defining mu_limit. So why do we need to specify the ...
% non-autonomous frequency again? The reason is that eta CAN be the continuation parameter but does NOT HAVE TO BE the continuation ...
% parameter. In order to deal with this uncertainty, we introduce the variable "non_auto_freq" which sets the non-autonomous ...
% frequency. In this case, the non-autonomous frequency eta is the continuation parameter mu. Due to this dependency, we have ...
% to set "non_auto_freq" as function handle @(mu):
non_auto_freq = @(mu) mu;
% "non_auto_freq" ALWAYS has to be a function handle @(mu) if it depends on mu. This also allows a great flexibility since the ...
% non-autonomous frequency can be an arbitrary function of mu, e.g. @(mu) 10*mu. In the other case that the non-autonomous ...
% frequency is independent from mu and therefore constant throughout the continuation (i.e. another parameter is the continuation ...
% parameter), we can define "non_auto_freq" either as double (e.g. non_auto_freq = 1.5) or as function handle ...
% (e.g. non_auto_freq = @(mu) 1.5).
% Moreover, we have to set an initial "guess" for the autonomous frequency, which CoSTAR uses as an initial value (IV) for the ...
% autonomous frequencies when iterating to the first point on the curve. This parameter is called "auto_freq" and we set it to
auto_freq = 1;
%
% Last but not least, we set variables which are used to complete the initial value (IV) where the nonlinear system solver ...
% fsolve starts to find the first approximate solution of equation (6) at mu0 (i.e. the first point on the curve), referred to as ...
% Z0 = Z(theta_1,theta_2,mu0). Using finite differences, the initial value is created via a first order multi-dimensional Fourier ...
% series:
% Z_IV(theta_1,theta_2) = C0 + C1_1*cos(theta_1) + C1_2*cos(theta_2) + C1_12*cos(theta_1 + theta_2) + ...
%                            + S1_1*sin(theta_1) + S1_2*sin(theta_2) + S1_12*sin(theta_1 + theta_2)
% All coefficients can be set by the user. They have to be column vectors of dimension dim and their default value is the zero ...
% vector. The coefficients are stored in the matrices C1_mat = [C1_1, C1_2, C1_12] and S1_mat = [S1_1, S1_2, S1_12]. It is ...
% important to note that the better Z_IV matches the approximate solution Z0, the faster fsolve converges towards Z0. If Z_IV is ...
% too far away from Z0 and/or the discretisation is too coarse, it may happen that fsolve does not converge at all! In general, it ...
% can be quite challenging to find suitable values for the parameters of the initial value. For our Jeffcott(-Laval) Rotor example, 
% we use (the values look a bit random, but they were determined to ensure fast convergence):
C0 = [-0.2; -0.2; 0; 0];        % We set C0 like this because we expect a constant shift in the state variables z1 and z2 due to Fg
C1_mat = [  0,    1.35, 0;      % Since C1_12 = [0; 0; 0; 0], the third column can be omitted.
          -0.35,   0,   0;
          -0.95,   0,   0;
            0,   -1.35, 0];
S1_mat = [-0.38,   0,   0;      % Since C1_12 = [0; 0; 0; 0], the third column can be omitted.
            0,   -1.35, 0;  
            0,   -1.35, 0;
          0.875,   0,   0];


%            2.2.2 The CoSTAR settings              
%
% All information and settings which CoSTAR needs are defined in a structure array called "options". 
% The structure "options" itself consists of structure arrays that define important parameters used by different modules of CoSTAR.
% 
% CoSTAR ALWAYS needs the following "option" structures: "options.system", "options.opt_sol" and "options.opt_init".
% Depending on the system and problem, CoSTAR might need some or all of the following "option" structures additionally: 
% "options.opt_approx_method":  Required when calculating (quasi-) periodic solutions.
% "options.opt_cont":           Required when running a continuation.
% "options.opt_stability":      Optional when calculating the stability of solutions.
% In this case, "options.opt_approx_method" and "options.opt_cont" are additionally needed.
% 
% Each of the "option" structures contain mandatory fields which ALWAYS have to be set. 
% Furthermore, there are optional fields that CAN be set. Most of the optional fields have a default value. 
% However, even optional fields NEED to be set in some cases (denoted as "Opt-Need.", e.g. 'param' in this example, see below).
% 
% IMPORTANT: All option structures must be created by the "costaropts" function. The syntax of the arguments of "costaropts" is ...
%            equivalent to the MATLAB struct function, i.e. costaropts(fieldname1,value1,...,fieldnameN,valueN).
%
% Let us start with the "options.system" structure. There are three mandatory fields, one optional-needed field (as in most cases) ...
% and one optional field:
options.system = costaropts('order',1,'dim',4,'rhs',Fcn,'param',param,'info','Continuation of Jeffcott-Laval Rotor');
% Mandatory fields: - 'order':  Describes the order of the ODE. As CoSTAR takes a system of differential equations of first order ...
%                               ( dz/dt = f(t,z,param) ), the order is 1.
%                   - 'dim':    Dimension of the state space. In this case, the dimension of the state variable vector z is 4.
%                               -> Allowed values: positive integer (scalar)
%                   - 'rhs':    Right-hand side of equation (4), which we already assigned to the variable Fcn.   
%                               -> Allowed values: function handle @(t,z,param)
% Opt-Need. field:  - 'param':  This field expects the previously defined "param" array. We NEED to set it because it is required ...
%                               by Fcn. Moreover, when executing a continuation, param is always necessary. However, param CAN be ...
%                               omitted when only calculating the initial solution (i.e. no continuation is carried out).
%                               -> Allowed values: [1xp] cell array, where p is the number of parameters for the RHS apart from t and z.
% Optional field:   - 'info':   Contains your individual text about the computation. This does not need to be set. However, it may ...
%                               help you later if you have forgotten what this computation is about (default: no text).
%                               -> Allowed values: char or string
%
% Next, there is the "options.opt_sol" structure. There are three mandatory fields and a total of four optional-needed fields, ...
% which we all need for mixed systems exhibiting one autonomous and one non-autonomous frequency. Apart from that, there are two ...
% optional fields, but we use their default values and therefore do not set them.
options.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','finite-difference','cont','on','stability','off', ...
                             'non_auto_freq',non_auto_freq,'auto_freq',auto_freq,'act_param',active_parameter);
% Mandatory fields: - 'sol_type':       We need to specify what type of solution CoSTAR has to calculate. For quasi-periodic ...
%                                       solutions, the key is 'quasiperiodic' or 'qps'.
%                   - 'cont':           As we want to execute a continuation, we set 'cont' = 'on'. If 'cont' = 'off', CoSTAR would ...
%                                       only calculate the initial solution z(tau,mu0).
%                   - 'stability':      CoSTAR computes the stability of the solution if 'stability' = 'on'. However, stability ...
%                                       calculation is not yet available for QPS when using the FDM, so we have to set it to 'off'.
% Opt-Need. field:  - 'approx_method':  Defines the approximation method used to calculate approximate solutions of equation (6). ...
%                                       For the FDM, the key is 'finite-difference' or 'fdm'.
%                   - 'non_auto_freq':  Function handle setting the non-autonomous frequency of the system. 'non_auto_freq' must ...
%                                       be set if the system exhibits excitation frequency(s) and is not allowed otherwise.
%                                       -> Allowed values: double or function handle @(mu) with value >= 'freq_limit' (see below)
%                                       -> Default value:  (no default value)
%                   - 'auto_freq':      Sets the initial value for the autonomous frequency(s) of the system. 'auto_freq' must be ...
%                                       set if the system exhibits autonomous frequency(s) and is not allowed otherwise.
%                                       -> Allowed values: double (scalar) with value >= 'freq_limit' (see below)
%                                       -> Default value:  (no default value)
%                   - 'act_param':      As we want to do a continuation, we have to tell CoSTAR where the continuation parameter is ...
%                                       located within param. To do that, we use the previously defined variable "active_parameter". ... 
%                                       Here, this field NEEDS to be set, because we provided a "param" array. If there is no ...
%                                       "param" array, 'act_param' may not be set.
%                                       -> Allowed values: positive integer (scalar) <= length(options.system.param)
%                                       -> Default value:  (no default value)
% Optional fields:  - 'freq_limit':     Defines the bottom limit of allowed base frequency values (frequency limit) of a solution. ...
%                                       CoSTAR stops if any base frequency falls below the limit. 
%                                       -> Allowed values: positive double (scalar)
%                                       -> Default value:  1e-4
%                   - 'display':        Controls the command window output.
%                                       -> Allowed values: 
%                                           - 'off':   Only warnings and errors are displayed.
%                                           - 'final': The latest solution and the termination message are displayed.
%                                           - 'iter':  Displays the iteration process of the initial solution, the latest five ...
%                                                      solutions during continuation and the termination message.
%                                           - 'iter-detailed': Similar to 'iter', but all computed solutions are displayed.
%                                           - 'step-control':  Similar to 'iter-detailed', but with additional step control ...
%                                                              information (if enabled).
%                                           - 'error-control': Similar to 'iter-detailed', but with additional error control ...
%                                                              information (if enabled).
%                                           - 'full':  All possible information are displayed. This is similar to the log file.
%                                       -> Default value: 'iter'
%
% Going on, we have to set the "options.opt_init" structure. The fields of the "options.opt_init" structure depend on the solution ...
% type as well as the chosen approximation method. For quasi-periodic solutions using the FDM, there are no mandatory fields and ...
% four optional fields, of which a maximum of 3 may be used. It is not allowed to use 'fdm_sol' in combination with 'c0', 'c1' or 's1'.
options.opt_init = costaropts('c0',C0,'c1_matrix',C1_mat,'s1_matrix',S1_mat);
% Optional fields: - 'c0':         Sets the Fourier series coefficient of the constant term used to create an initial value for fsolve ...
%                                  to find the first approximate solution Z0. We already defined C0 above.
%                                  -> Allowed values: [dim x 1] (double) array
%                                  -> Default value:  zeros(dim,1)
%                  - 'c1_matrix':  Sets the Fourier series coefficients of all three "cos" terms used to create an initial value for ...
%                                  fsolve to find the first approximate solution Z0. We already defined C1_mat above.
%                                  -> Allowed values: [dim x 1], [dim x 2] or [dim x 3] (double) array
%                                  -> Default value:  zeros(dim,3)
%                  - 's1_matrix':  Sets the Fourier series coefficients of all three "sin" terms used to create an initial value for ...
%                                  fsolve to find the first approximate solution Z0. We already defined S1_mat above.
%                                  -> Allowed values: [dim x 1], [dim x 2] or [dim x 3] (double) array
%                                  -> Default value:  zeros(dim,3)
%                   - 'fdm_sol':   The initial value can be taken from an already calculated solution. 'fdm_sol' takes the method ...
%                                  solution vector s (stored in Solution_object.s). If the number of intervals 'n_int_1' and ...
%                                  'n_int_2', defined in opt_approx_method (or its default values, see below), do not match the ...
%                                  number of intervals of 'fdm_sol', the provided solution is interpolated. In this case, the ...
%                                  number of intervals of 'fdm_sol' must be defined via the fields 'n_int_1_fdm_sol' and ... 
%                                  'n_int_2_fdm_sol' (see below). Moreover, the fields 'c0', 'c1' and 's1' are not allowed when ...
%                                  providing 'fdm_sol'.
%                                  -> Allowed values [dim*n_int_1_fdm_sol*n_int_2_fdm_sol x 1] (double) array
%                                  -> Default value: (no default value)
%                   - 'n_int_1_fdm_sol':  This field can be used to define the number of intervals n_int_1 of 'fdm_sol' if this ...
%                                         number does not match 'n_int_1' defined in opt_approx_method (or the default value of ...
%                                         n_int_1, see below).  Thus, this field is only allowed when using the field 'fdm_sol'.
%                                         -> Allowed values Positive integer >= 2
%                                         -> Default value: n_int_1 (see below)
%                   - 'n_int_2_fdm_sol':  This field can be used to define the number of intervals n_int_2 of 'fdm_sol' if this ...
%                                         number does not match 'n_int_2' defined in opt_approx_method (or the default value of ...
%                                         n_int_2, see below). Thus, this field is only allowed when using the field 'fdm_sol'.
%                                         -> Allowed values Positive integer >= 2
%                                         -> Default value: n_int_2 (see below)
% NOTE: For usage of the field 'fdm_sol', please see section 1.4 of the "Duffing Oscillator" example above.
%                  
% So far we have defined all "options" structures which CoSTAR always needs. Since we want to calculate a quasi-periodic solution ...
% and execute a continuation, we also have to set the "options.opt_approx_method" as well as the "options.opt_cont" structures. The ...
% fields of the "options.opt_approx_method" structure depend on the solution type as well as the chosen approximation method. For ...
% quasi-periodic solutions using the FDM, there are no mandatory fields and eight optional fields of which a maximum of six may be used.
options.opt_approx_method = costaropts('n_int_1',30,'scheme_1','central','approx_order_1',6,...
                                       'n_int_2',30,'scheme_2','central','approx_order_2',6);
% Optional fields: - 'n_int_1':         Sets the number of intervals into which the hyper-time domain is divided in theta_1- ...
%                                       direction. This means that the hyper-time domain is approximated by (n_int_1+1) points in ...
%                                       the range of theta_1 = [0, 2*pi]. n_int_1 and n_int_2 define the resolution of the FD grid.
%                                       -> Allowed values: Positive integer >= 2
%                                       -> Default value:  50
%                  - 'scheme_1':        This field refers to the discretisation scheme used to approximate the derivation dZ/dtheta_1.
%                                       -> Allowed values: 'central', 'forward', 'backward'
%                                       -> Default value:  'central'
%                  - 'approx_order_1':  Defines the order of approximation of dZ/dtheta_1.
%                                       -> Allowed values: Positive integer. Must be even number if 'scheme' = 'central'
%                                       -> Default value:  6
%                  - 'points_1':        Specifies the local grid points which are used to approximate dZ/dtheta_1. E.g.: If 'points' ...
%                                       is set to [-1,0,1], dZ/dtheta_1 at grid point index (i,j) is approximated by the torus ...
%                                       function values at (i-1,j), (i+0,j) and (i+1,j). Can be used INSTEAD OF 'scheme_1' and ...
%                                       'approx_order_1', i.e. 'points_1' is not allowed when specifying 'scheme_1' and/or ...
%                                       'approx_order_1' and vice versa.
%                                       -> Allowed values: Integer vector
%                                       -> Default value:  [-3,-2,-1,0,1,2,3]
%                   - The meaning of all fields with index "_2" is almost identical to the corresponding fields with index "_1", ...
%                     but they refer to the discretisation in theta_2-direction (instead of theta_1-direction).
% NOTE: It is not necessary to set 'scheme_1/2' and 'approx_order_1/2' since the default values are used. However, it is ...
%       demonstrated here in order to show the fields and possible values. For usage of the fields 'points_1/2', please see ...
%       section 1.4 of the "Duffing Oscillator" example above or section 3.2 of the "Coupled van der Pol Oscillator" example below.
%
options.opt_cont = costaropts('mu_limit',mu_limit,'step_width',0.5,'pred','secant','direction',-1);
% Mandatory fields: - 'mu_limit':    Sets the limits of the continuation. For this purpose, we defined the "mu_limit" variable.
%                                    -> Allowed values: [1x2] double array of increasing numerical values
% Optional fields:  - 'step_width':  Defines the initial step width (default: 0.1). The step width will be altered in the range ...
%                                    of step_width*[0.2, 5]. It is set here in order to reduce the numerical effort. Step control ...
%                                    is explained in a separate tutorial in detail.
%                   - 'pred':        Defines the method to calculate the predictor point (default: tangent). When calculating ...
%                                    quasi-periodic solutions using the FDM, is is HIGHLY advised to use the secant predictor since ...
%                                    the calculation of the local tangent requires a huge numerical effort. 
%                   - 'direction':   We start the continuation at the upper limit of mu, so we need to decrease mu during the ...
%                                    continuation. This is done by setting the field 'direction' to -1 (default: 1).
%
% Finally, we are done defining the required settings. All solution type and approximation method specific fields, which are the ...
% fields of "options.opt_init" and "options.opt_approx_method", were explained above. Concerning the rest of the "options" structures ...
% ("options.system", "options.opt_sol" and "options.opt_cont"), only the necessary fields were defined and explained to some extend.
% If you want to have a deeper insight into the "options" structures and its fields, please use the "costarhelp" function by typing ...
% "costarhelp.options" in the command window. In order to directly open the help pages of particular "options" structures, type ...
% "costarhelp.<name_of_options_structure>", e.g. "costarhelp.opt_cont". In case of "options.opt_init" and "options.opt_approx_method", ...
% type "costarhelp.<name_of_options_structure>('QPS','FDM')" ("QPS": Quasi-Periodic Solution).


%     2.2.3 Calling CoSTAR and running the simulation
%
% Now we can run the computation. This is done by invoking the "costar" function and passing the "options" structure as an input ...
% argument. "costar" returns two objects: 
% - DynamicalSystem object "DYN":  Saves all the information and settings which are contained in "options". It can be used to ...
%                                  restart the computation and it is necessary for postprocessing.
% - Solution object "S": Stores the information that CoSTAR calculated and can further be used for postprocessing.
%
[S,DYN] = costar(options);                          % CoSTAR is called by costar(options).
%
% During the computation, CoSTAR displays information in the command window:
% - At the beginning, the iteration process of fsolve trying to find the first point on the curve is shown.
% - As soon as fsolve succeeded, CoSTAR announces "Initial solution found!". ...
%   If the stability of a solution is additionally computed, the message is supplemented by the information (stable) or (unstable).
% - After that, the continuation starts and CoSTAR displays "Iter: <XXX> -- mu = <XXX> -- stepwidth = <XXX>" for the latest five ...
%   computed solutions.
%       * "Iter: <XXX>" depicts the number of the computed point on the curve. Please keep in mind that the initial solution is ...
%          counted as Iter = 1.
%       * "mu = <XXX>" shows the value of the continuation parameter mu for the related point on the curve.
%       * "stepwidth = <XXX>" displays the step width that was used to compute the point on the curve.
%       * "(un)stable" reports whether the solution is stable or unstable if the stability was computed.
% - Finally, CoSTAR reports the reason of termination of the continuation.
% 
% Please note that the command window output described above is the default output and it may change if the options.opt_sol field ...
% 'display' is manually set.
% 
% Furthermore, a log file named "CoSTAR_Log_ID_yyyy-mm-dd_hh.mm.ss.txt" (yyyy-mm-dd and hh.mm.ss show the date and time of day ...
% when the computation started) is created in the current directory of MATLAB, giving a more in-depth view of the computation.


%                2.3 Postprocessing                 %
%
% As you have probably noticed, CoSTAR automatically creates a diagram as well. By default, the maximum of the Euclidean norm of ...
% the torus function against the continuation parameter mu. This means that for every computed approximate solution ...
% Z(theta_1,theta_2,mu), the Euclidean norm of (50*50) torus function points is calculated. These points are equidistant distributed ...
% on the hyper-time domain. After the Euclidean norm of all torus function points were computed, the maximum thereof is taken and ...
% plotted against mu. This can be understood as a mapping of the computed curve in R^(n+2)-dimensional space into 2D space. ...
% The line is displayed in blue since the stability was not computed.
%
% In order to plot the hyper-time surfaces Z_i(theta_1,theta_2,mu) (torus function components), we need to call the "solplot" ...
% function. Similar to the "costar" function, solplot expects a structure that defines all required options for the plot.
solplot_options_2 = costaropts('zaxis',@(z) z(:,:,1),'space','hypertime','resolution',30,'index',[5,22]);
% Mandatory fields: - 'zaxis':       Defines what is plotted on the vertical axis. "@(z) z(:,:,1)" plots the first component (i = 1) ...
%                                    of the torus function against the hyper-time domain [0, 2*pi]^2.
%                   - 'space':       Specifies the "domain" of the plot. 'hypertime' plots the hyper-time surfaces of the solution.
% Optional fields:  - 'resolution':  Sets the number of points for the plot in each theta-direction.
%                   - 'index':       Defines at which points Z_i(theta_1,theta_2,mu) is plotted, e.g. if index = 25, the solution at ...
%                                    point number 25 (i.e. the 25th point which was calculated) is plotted
%
% Now we can call the "solplot" function. It is a function of the solution class object S, which is why we have to call it by ...
% "S.solplot". Apart from the "opt_solplot" structure, solplot also requires the DynamicalSystem class object DYN. 
% solplot creates the desired plot and additionally returns a structure storing the corresponding z-values, hypertime values and mu-values.
% However, the fields of the output structure depends on the options, so it may change in other cases.
solplot_output_2 = S.solplot(DYN,solplot_options_2);
%
% We do not go into further postprocessing details here as this would exceed the scope of this tutorial.
% Comprehensive explanations of the postprocessing functions can be found in the corresponding tutorials ...
% (Tutorial_Postprocessing_<...>: contplot, solget and solplot) and the associated examples provide short exemplary code. 
% An overview of the available options is given via the costarhelp function by typing "costarhelp.costar" in the command window.


% Now we are done with the "Jeffcott(-Laval) Rotor" example!
% Going on, we will learn how to deal with full autonomous systems, exhibiting no external forcing, on the basis of two coupled ...
% van der Pol oscillators.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    Ex. No 3: Coupled van der Pol Oscillator     %%
%              Full Autonomous System               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
clear variables; clc; close all;                    % Let's clean our "desk" before we begin with our second example.

%                3.1 Introduction                   %
%
% The third example we have a look on are two coupled van der Pol oscillators which are given by the dimensionless differential equations
%   x1'' + epsilon * (x1^2 - 1) * x1' +              x1 = alpha * (x2 - x1)     (7.1)
%   x2'' + epsilon * (x2^2 - 1) * x2' + (1 + beta) * x2 = alpha * (x1 - x2)     (7.2)
% epsilon is the coefficient of the non-linearity, alpha the coupling constant, beta a constant of the linear stiffness of x2, ...
% xi' = dxi/dtau and xi'' = dxi'/dtau (i = 1,2; tau being the dimensionless time). However, CoSTAR always needs the equation to be ...
% of the form dz/dt = f(t,z,param) (param represents all additional parameters), which is why we have to transform (7) into a ...
% system of four differential equations of first order. To do that, we introduce the state variable vector ...
% z = [z1; z2; z3; z4] = [x1; x2; x1'; x2'], leading to:
% dz/dtau = f(z,epsilon,alpha,beta)  (8)  <=>  z1' = z3
%                                              z2' = z4
%                                              z3' = - epsilon * (z1^2 - 1) * z3 -            z1 + alpha * (z2 - z1)
%                                              z4' = - epsilon * (z2^2 - 1) * z4 - (1+beta) * z2 + alpha * (z1 - z2)
%
% Our aim is to approximate the quasi-periodic solution of equation (8) z(tau) for epsilon in the range of [0.1, 1.25] using the FDM. ...
% Instead of the quasi-periodic solution itself, we calculate the (image of the) torus function Z = Z(theta_1,theta_2) that ...
% describes the torus on which the quasi-periodic solution evolves, using the hyper-time invariance equation:
% dZ/dtheta_1 * omega_1 + dZ/dtheta_2 * omega_2 = f(Z,theta_1,theta_2,param)   (9),
% where omega_1 and omega_2 are the unknown autonomous frequencies and where f is the right-hand side of (8). This problem can be ...
% rewritten into finding the zero set of the function g: R^(n+3) -> R^(n+2) with g = 0 and for epsilon in [0.1, 1.25], which defines ...
% a curve in (n+3)-dimensional space (n depends on the dimension of the system as well as the finite difference discretisation). ...
% Hence, a solution Z(theta_1,theta_2) is also denoted as a "point on the curve" in the following explanations. CoSTAR will ...
% approximate discrete points on this curve by executing a path continuation. As epsilon is varied, the continuation parameter is ...
% mu = epsilon. The remaining parameters are set to:
alpha = 0.1;    beta = 1.1;


%       3.2 Continuation of nonlinear damping       %
%
%          3.2.1 Setting useful variables           
%
% Before we specify the settings needed by CoSTAR, we introduce some important variables, which we will use later on. This is not ...
% necessarily needed but it helps to keep an overview of the most important variables/settings. Furthermore, important aspects of ...
% CoSTAR are explained here, making the following section "3.2.2 The CoSTAR settings" clearer.
mu_limit = [0.1, 1.25];                             % mu_limits = epsilon_limits = [0.1, 1.25] sets the limits of our continuation.
%
epsilon0 = mu_limit(1);                             % epsilon0 defines the epsilon-value at which the continuation begins.
%
Fcn = @(t,z,param) coupledvdp(t,z,param);           % Fcn is a function handle containing the right-hand side (RHS) of equation (8).
% You may have noticed that Fcn is a function of t, z and param, whereas the right-hand side of (8) is only a function of z, ...
% epsilon, alpha and beta. This is because CoSTAR ALWAYS requires the definition of Fcn as "Fcn = @(t,z,param) ..." when ...
% calculating quasi-periodic solutions. param is a cell array storing all parameters, apart from t and z, that need to be passed ...
% to (8). The time t as well as the state variable vector z are always treated separately and therefore not included in param. ...
% Here, we need to define param since we need to pass the parameters epsilon, alpha and beta to Fcn. The name of the ...
% "time argument" being t (and not tau) is required by CoSTAR. It is equal to our dimensionless time tau.
%
% TASK: Open the function "coupledvdp" (click the right mouse button right on it and choose 'Open "coupledvdp"' or go into the ...
%       "RHS" subfolder located in the main path of CoSTAR and double click on the function). Have a look at how the equation is  ...
%       defined and compare that to our system right next to equation (8).
% IMPORTANT: Please pay attention to how the state variables z1, z2, z3 and z4 are defined and how the parameters epsilon, alpha ...
%            and beta are extracted from param. Moreover, take notice the definition and explanation of the time variables t1 and t2.
%
% Now we define the "param" array. It is important that this is a cell array AND the order of the parameters placed in param must ...
% correspond to the definitions in the "coupledvdp" function! For example, alpha is defined by alpha = param{2} in the "coupledvdp" ...
% function. Therefore, alpha has to be the SECOND variable in the "param" array. For the variable epsilon, we use epsilon0 since ...
% the continuation starts at the epsilon-value of epsilon0.
param = {epsilon0, alpha, beta};
% Next, we have to tell CoSTAR where the continuation parameter is located within param. We also call this the "active parameter". ...
% This is done by defining an integer variable which is used to get the continuation parameter from param by cell indexing, i.e. ...
% continuation parameter mu = param{active_parameter}. As we want to continue the curve via epsilon and the corresponding value ...
% epsilon0 is the FIRST element of param, we set:
active_parameter = 1;
%
% Due to the system being fully autonomous, we have to set an initial "guess" for the autonomous frequencies, which CoSTAR uses as ...
% an initial value (IV) for the autonomous frequencies when iterating to the first point on the curve. This parameter is called ...
% "auto_freq" and we set it to
auto_freq = [1.04, 1.5];
% Last but not least, we set variables which are needed to complete the initial value (IV) where the nonlinear system solver fsolve ...
% starts to find the first approximate solution of equation (9) at mu0 (i.e. the first point on the curve), referred to as ...
% Z0 = Z(theta_1,theta_2,mu0). Using finite differences, the initial value is created via a first order multi-dimensional Fourier ...
% series:
% Z_IV(theta_1,theta_2) = C0 + C1_1*cos(theta_1) + C1_2*cos(theta_2) + C1_12*cos(theta_1 + theta_2) + ...
%                            + S1_1*sin(theta_1) + S1_2*sin(theta_2) + S1_12*sin(theta_1 + theta_2)
% All coefficients can be set by the user. They have to be column vectors of dimension dim and their default value is the zero ...
% vector. The coefficients are stored in the matrices C1_mat = [C1_1, C1_2, C1_12] and S1_mat = [S1_1, S1_2, S1_12]. It is ...
% important to note that the better Z_IV matches the approximate solution Z0, the faster fsolve converges towards Z0. If Z_IV is ...
% too far away from Z0 and/or the discretisation is too coarse, it may happen that fsolve does not converge at all! In general, it ...
% can be quite challenging to find suitable values for the parameters of the initial value. For our coupled van der Pol example, we use:
C1_mat = [0,   0,   0;          % Since C1_12 = [0; 0; 0; 0], the third column can be omitted.          
          0, -1.4,  0;
          2,   0,   0;
          0,  2.1,  0];
S1_mat = [2,   0,   0;          % Since C1_12 = [0; 0; 0; 0], the third column can be omitted.
          0,  1.4,  0;
          0,   0,   0;
          0,  2.1,  0];


%            3.2.2 The CoSTAR settings              
%
% All information and settings which CoSTAR needs are defined in a structure array called "options". 
% The structure "options" itself consists of structure arrays that define important parameters used by different modules of CoSTAR.
% 
% CoSTAR ALWAYS needs the following "option" structures: "options.system", "options.opt_sol" and "options.opt_init".
% Depending on the system and problem, CoSTAR might need some or all of the following "option" structures additionally: 
% "options.opt_approx_method":  Required when calculating (quasi-) periodic solutions.
% "options.opt_cont":           Required when running a continuation.
% "options.opt_stability":      Optional when calculating the stability of solutions.
% In this case, "options.opt_approx_method" and "options.opt_cont" are additionally needed.
% 
% Each of the "option" structures contain mandatory fields which ALWAYS have to be set. 
% Furthermore, there are optional fields that CAN be set. Most of the optional fields have a default value. 
% However, even optional fields NEED to be set in some cases (denoted as "Opt-Need.", e.g. 'param' in this example, see below).
% 
% IMPORTANT: All option structures must be created by the "costaropts" function. The syntax of the arguments of "costaropts" is ...
%            equivalent to the MATLAB struct function, i.e. costaropts(fieldname1,value1,...,fieldnameN,valueN).
%
% Let us start with the "options.system" structure. There are three mandatory fields, one optional-needed field (as in most cases) ...
% and one optional field:
options.system   = costaropts('order',1,'dim',4,'rhs',Fcn,'param',param,'info','Continuation of Coupled van der Pol Oscillator');
% Mandatory fields: - 'order':  Describes the order of the ODE. As CoSTAR takes a system of differential equations of first order ...
%                               ( dz/dt = f(t,z,param) ), the order is 1.
%                   - 'dim':    Dimension of the state space. In this case, the dimension of the state variable vector z is 4.
%                               -> Allowed values: positive integer (scalar)
%                   - 'rhs':    Right-hand side of equation (8), which we already assigned to the variable Fcn.   
%                               -> Allowed values: function handle @(t,z,param)
% Opt-Need. field:  - 'param':  This field expects the previously defined "param" array. We NEED to set it because it is required ...
%                               by Fcn. Moreover, when executing a continuation, param is always necessary. However, param CAN be ...
%                               omitted when only calculating the initial solution (i.e. no continuation is carried out).
%                               -> Allowed values: [1xp] cell array, where p is the number of parameters for the RHS apart from t and z.
% Optional field:   - 'info':   Contains your individual text about the computation. This does not need to be set. However, it may ...
%                               help you later if you have forgotten what this computation is about (default: no text).
%                               -> Allowed values: char or string
%
% Next, there is the "options.opt_sol" structure. There are three mandatory fields and a total of four optional-needed fields. ...
% However, we only need three of the optional-needed fields because the system is fully autonomous. The remaining optional-needed ...
% field ('non_auto_freq') is needed when the system exhibits autonomous frequency(s). Apart from that, there are two optional ...
% fields, but we use their default values and therefore do not set them.
options.opt_sol = costaropts('sol_type','quasiperiodic','approx_method','finite-difference','cont','on','stability','off', ...
                             'auto_freq',auto_freq,'act_param',active_parameter);
% Mandatory fields: - 'sol_type':       We need to specify what type of solution CoSTAR has to calculate. For quasi-periodic ...
%                                       solutions, the key is 'quasiperiodic' or 'qps'.
%                   - 'cont':           As we want to execute a continuation, we set 'cont' = 'on'. If 'cont' = 'off', CoSTAR would ...
%                                       only calculate the initial solution z(tau,mu0).
%                   - 'stability':      CoSTAR computes the stability of the solution if 'stability' = 'on'. However, stability ...
%                                       calculation is not yet available for QPS when using the FDM, so we have to set it to 'off'.
% Opt-Need. field:  - 'approx_method':  Defines the approximation method used to calculate approximate solutions of equation (9). ...
%                                       For the FDM, the key is 'finite-difference' or 'fdm'.
%                   - 'auto_freq':      Sets the initial value for the autonomous frequency(s) of the system. 'auto_freq' must be ...
%                                       set if the system exhibits autonomous frequency(s) and is not allowed otherwise.
%                                       -> Allowed values: [1x2] double array with values >= 'freq_limit' (see below)
%                                       -> Default value:  (no default value)
%                   - 'act_param':      As we want to do a continuation, we have to tell CoSTAR where the continuation parameter is ...
%                                       located within param. To do that, we use the previously defined variable "active_parameter". ... 
%                                       Here, this field NEEDS to be set, because we provided a "param" array. If there is no ...
%                                       "param" array, 'act_param' may not be set.
%                                       -> Allowed values: positive integer (scalar) <= length(options.system.param)
%                                       -> Default value:  (no default value)
% Optional fields:  - 'freq_limit':     Defines the bottom limit of allowed base frequency values (frequency limit) of a solution. ...
%                                       CoSTAR stops if any base frequency falls below the limit. 
%                                       -> Allowed values: positive double (scalar)
%                                       -> Default value:  1e-4
%                   - 'display':        Controls the command window output.
%                                       -> Allowed values: 
%                                           - 'off':   Only warnings and errors are displayed.
%                                           - 'final': The latest solution and the termination message are displayed.
%                                           - 'iter':  Displays the iteration process of the initial solution, the latest five ...
%                                                      solutions during continuation and the termination message.
%                                           - 'iter-detailed': Similar to 'iter', but all computed solutions are displayed.
%                                           - 'step-control':  Similar to 'iter-detailed', but with additional step control ...
%                                                              information (if enabled).
%                                           - 'error-control': Similar to 'iter-detailed', but with additional error control ...
%                                                              information (if enabled).
%                                           - 'full':  All possible information are displayed. This is similar to the log file.
%                                       -> Default value: 'iter'
%
% Going on, we have to set the "options.opt_init" structure. The fields of the "options.opt_init" structure depend on the solution ...
% type as well as the chosen approximation method. For quasi-periodic solutions using the FDM, there are no mandatory fields and ...
% four optional fields, of which a maximum of 3 may be used. It is not allowed to use 'fdm_sol' in combination with 'c0', 'c1' or 's1'.
options.opt_init = costaropts('c1_matrix',C1_mat,'s1_matrix',S1_mat);
% Optional fields: - 'c0':         Sets the Fourier series coefficient of the constant term used to create an initial value for fsolve ...
%                                  to find the first approximate solution Z0. We do not need 'c0' here so we do not specify it.
%                                  -> Allowed values: [dim x 1] (double) array
%                                  -> Default value:  zeros(dim,1)
%                  - 'c1_matrix':  Sets the Fourier series coefficients of all three "cos" terms used to create an initial value for ...
%                                  fsolve to find the first approximate solution Z0. We already defined C1_mat above.
%                                  -> Allowed values: [dim x 1], [dim x 2] or [dim x 3] (double) array
%                                  -> Default value:  zeros(dim,3)
%                  - 's1_matrix':  Sets the Fourier series coefficients of all three "sin" terms used to create an initial value for ...
%                                  fsolve to find the first approximate solution Z0. We already defined S1_mat above.
%                                  -> Allowed values: [dim x 1], [dim x 2] or [dim x 3] (double) array
%                                  -> Default value:  zeros(dim,3)
%                   - 'fdm_sol':   The initial value can be taken from an already calculated solution. 'fdm_sol' takes the method ...
%                                  solution vector s (stored in Solution_object.s). If the number of intervals 'n_int_1' and ...
%                                  'n_int_2', defined in opt_approx_method (or its default values, see below), do not match the ...
%                                  number of intervals of 'fdm_sol', the provided solution is interpolated. In this case, the ...
%                                  number of intervals of 'fdm_sol' must be defined via the fields 'n_int_1_fdm_sol' and ... 
%                                  'n_int_2_fdm_sol' (see below). Moreover, the fields 'c0', 'c1' and 's1' are not allowed when ...
%                                  providing 'fdm_sol'.
%                                  -> Allowed values [dim*n_int_1_fdm_sol*n_int_2_fdm_sol x 1] (double) array
%                                  -> Default value: (no default value)
%                   - 'n_int_1_fdm_sol':  This field can be used to define the number of intervals n_int_1 of 'fdm_sol' if this ...
%                                         number does not match 'n_int_1' defined in opt_approx_method (or the default value of ...
%                                         n_int_1, see below).  Thus, this field is only allowed when using the field 'fdm_sol'.
%                                         -> Allowed values Positive integer >= 2
%                                         -> Default value: n_int_1 (see below)
%                   - 'n_int_2_fdm_sol':  This field can be used to define the number of intervals n_int_2 of 'fdm_sol' if this ...
%                                         number does not match 'n_int_2' defined in opt_approx_method (or the default value of ...
%                                         n_int_2, see below). Thus, this field is only allowed when using the field 'fdm_sol'.
%                                         -> Allowed values Positive integer >= 2
%                                         -> Default value: n_int_2 (see below)
% NOTE: For usage of the field 'fdm_sol', please see section 1.4 of the "Duffing Oscillator" example above.
%  
% So far we have defined all "options" structures which CoSTAR always needs. Since we want to calculate a quasi-periodic solution ...
% and execute a continuation, we also have to set the "options.opt_approx_method" as well as the "options.opt_cont" structures. The ...
% fields of the "options.opt_approx_method" structure depend on the solution type as well as the chosen approximation method. For ...
% quasi-periodic solutions using the FDM, there are no mandatory fields and eight optional fields of which a maximum of six may be used.
options.opt_approx_method = costaropts('n_int_1',35,'points_1',[-4,-3,-2,-1,0,1,2],...
                                       'n_int_2',35,'points_2',[-4,-3,-2,-1,0,1,2]);
% Optional fields: - 'n_int_1':         Sets the number of intervals into which the hyper-time domain is divided in theta_1- ...
%                                       direction. This means that the hyper-time domain is approximated by (n_int_1+1) points in ...
%                                       the range of theta_1 = [0, 2*pi]. n_int_1 and n_int_2 define the resolution of the FD grid.
%                                       -> Allowed values: Positive integer >= 2
%                                       -> Default value:  50
%                  - 'points_1':        Specifies the local grid points which are used to approximate dZ/dtheta_1. E.g.: If 'points' ...
%                                       is set to [-1,0,1], dZ/dtheta_1 at grid point index (i,j) is approximated by the torus ...
%                                       function values at (i-1,j), (i+0,j) and (i+1,j). Can be used INSTEAD OF 'scheme_1' and ...
%                                       'approx_order_1', i.e. 'points_1' is not allowed when specifying 'scheme_1' and/or ...
%                                       'approx_order_1' and vice versa.
%                                       -> Allowed values: Integer vector
%                                       -> Default value:  [-3,-2,-1,0,1,2,3]
%                  - 'scheme_1':        This field refers to the discretisation scheme used to approximate the derivation dZ/dtheta_1.
%                                       -> Allowed values: 'central', 'forward', 'backward'
%                                       -> Default value:  'central'
%                  - 'approx_order_1':  Defines the order of approximation of dZ/dtheta_1.
%                                       -> Allowed values: Positive integer. Must be even number if 'scheme' = 'central'
%                                       -> Default value:  6
%                   - The meaning of all fields with index "_2" is almost identical to the corresponding fields with index "_1", ...
%                     but they refer to the discretisation in theta_2-direction (instead of theta_1-direction).
% NOTE: For usage of the fields 'scheme_1/2' and 'approx_order_1/2, please see the "Duffing Oscillator" or "Jeffcott(-Laval) Rotor" ...
%       example above.
%
options.opt_cont = costaropts('mu_limit',mu_limit,'step_width',1.5,'step_control','off','pred','secant');
% Mandatory fields: - 'mu_limit':      Sets the limits of the continuation. For this purpose, we defined the "mu_limit" variable.
%                                      -> Allowed values: [1x2] double array of increasing numerical values
% Optional fields:  - 'step_width':    Defines the (initial) step width (default: 0.1). The step width will be altered in the range ...
%                                      of step_width*[0.2, 5].
%                   - 'step_control':  Sets the step control method. We do not want to use step control, so we set it to 'off'.
%                   - 'pred':          Defines the method to calculate the predictor point (default: tangent). When calculating ...
%                                      quasi-periodic solutions using the FDM, is is HIGHLY advised to use the secant predictor since ...
%                                      the calculation of the local tangent requires a huge numerical effort. 
% NOTE: The fields belonging to the step control ('step_width' and 'step_control') are set in order to reduce the numerical effort. ...
%       They are explained in a separate step control tutorial so you can ignore them at the moment.
%
% Finally, we are done defining the required settings. All solution type and approximation method specific fields, which are the ...
% fields of "options.opt_init" and "options.opt_approx_method", were explained above. Concerning the rest of the "options" structures ...
% ("options.system", "options.opt_sol" and "options.opt_cont"), only the necessary fields were defined and explained to some extend.
% If you want to have a deeper insight into the "options" structures and its fields, please use the "costarhelp" function by typing ...
% "costarhelp.options" in the command window. In order to directly open the help pages of particular "options" structures, type ...
% "costarhelp.<name_of_options_structure>", e.g. "costarhelp.opt_cont". In case of "options.opt_init" and "options.opt_approx_method", ...
% type "costarhelp.<name_of_options_structure>('QPS','FDM')" ("QPS": Quasi-Periodic Solution).


%     3.2.3 Calling CoSTAR and running the simulation
%
% Now we can run the computation. This is done by invoking the "costar" function and passing the "options" structure as an input ...
% argument. "costar" returns two objects: 
% - DynamicalSystem object "DYN":  Saves all the information and settings which are contained in "options". It can be used to ...
%                                  restart the computation and it is necessary for postprocessing.
% - Solution object "S": Stores the information that CoSTAR calculated and can further be used for postprocessing.
%
[S,DYN] = costar(options);                          % Calling CoSTAR and performing the continuation
%
% During the computation, CoSTAR displays information in the command window:
% - At the beginning, the iteration process of fsolve trying to find the first point on the curve is shown.
% - As soon as fsolve succeeded, CoSTAR announces "Initial solution found!". ...
%   If the stability of a solution is additionally computed, the message is supplemented by the information (stable) or (unstable).
% - After that, the continuation starts and CoSTAR displays "Iter: <XXX> -- mu = <XXX> -- stepwidth = <XXX>" for the latest five ...
%   computed solutions.
%       * "Iter: <XXX>" depicts the number of the computed point on the curve. Please keep in mind that the initial solution is ...
%          counted as Iter = 1.
%       * "mu = <XXX>" shows the value of the continuation parameter mu for the related point on the curve.
%       * "stepwidth = <XXX>" displays the step width that was used to compute the point on the curve.
%       * "(un)stable" reports whether the solution is stable or unstable if the stability was computed.
% - Finally, CoSTAR reports the reason of termination of the continuation.
% 
% Please note that the command window output described above is the default output and it may change if the options.opt_sol field ...
% 'display' is manually set.
% 
% Furthermore, a log file named "CoSTAR_Log_ID_yyyy-mm-dd_hh.mm.ss.txt" (yyyy-mm-dd and hh.mm.ss show the date and time of day ...
% when the computation started) is created in the current directory of MATLAB, giving a more in-depth view of the computation.


%                3.3 Postprocessing                 %
%
% As you have probably noticed, CoSTAR automatically creates a diagram as well. By default, the maximum of the Euclidean norm of ...
% the torus function against the continuation parameter mu. This means that for every computed approximate solution ...
% Z(theta_1,theta_2,mu), the Euclidean norm of (50*50) torus function points is calculated. These points are equidistant distributed ...
% on the hyper-time domain. After the Euclidean norm of all torus function points were computed, the maximum thereof is taken and ...
% plotted against mu. This can be understood as a mapping of the computed curve in R^(n+3)-dimensional space into 2D space. ...
% The line is displayed in blue since the stability was not computed.
%
% In order to plot the hyper-time surfaces Z_i(theta_1,theta_2,mu) (torus function components), we need to call the "solplot" ...
% function. Similar to the "costar" function, solplot expects a structure that defines all required options for the plot.
solplot_options_3 = costaropts('zaxis',@(z) z(:,:,1),'space','hypertime','resolution',35,'index',[5,20]);
% Mandatory fields: - 'zaxis':       Defines what is plotted on the vertical axis. "@(z) z(:,:,1)" plots the first component (i = 1) ...
%                                    of the torus function against the hyper-time domain [0, 2*pi]^2.
%                   - 'space':       Specifies the "domain" of the plot. 'hypertime' plots the hyper-time surfaces of the solution.
% Optional fields:  - 'resolution':  Sets the number of points for the plot in each theta-direction.
%                   - 'index':       Defines at which points Z_i(theta_1,theta_2,mu) is plotted, e.g. if index = 25, the solution at ...
%                                    point number 25 (i.e. the 25th point which was calculated) is plotted
%
% Now we can call the "solplot" function. It is a function of the solution class object S, which is why we have to call it by ...
% "S.solplot". Apart from the "opt_solplot" structure, solplot also requires the DynamicalSystem class object DYN. 
% solplot creates the desired plot and additionally returns a structure storing the corresponding z-values, hypertime values and mu-values.
% However, the fields of the output structure depends on the options, so it may change in other cases.
solplot_output_3 = S.solplot(DYN,solplot_options_3);
%
% We do not go into further postprocessing details here as this would exceed the scope of this tutorial.
% Comprehensive explanations of the postprocessing functions can be found in the corresponding tutorials ...
% (Tutorial_Postprocessing_<...>: contplot, solget and solplot) and the associated examples provide short exemplary code. 
% An overview of the available options is given via the costarhelp function by typing "costarhelp.costar" in the command window.


% Finally, we are done with the "Coupled van der Pol Oscillator" example!



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  Final Words                    %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The CoSTAR tutorial on calculating quasi-periodic solutions using the Finite Difference Method is now finished.
% For additional information, please use the "costarhelp" function and/or the CoSTAR manual.

% If you are interested in learning about further capabilities of CoSTAR, you are invited to have a look at the other tutorials as well.

% See you soon!