% This function is a method of the subclass AM_QPS_FDM.
% It is a help function file for the costarhelp functionality.
%
% This help file is identified by its name.
%
% @help_struct: struct of structs describing the parameters and options for the respective opt_approx_method structure

function help_struct = s_help_opt_approx_method_QPS_FDM()

    help_struct.info = ['opt_approx_method --- quasi-periodic solution --- finite difference method \n\n' ...
                        'Nomenclature used in the following: \n' ...
                        '  i              grid point index in theta_1-direction \n' ...
                        '  j              grid point index in theta_2-direction \n' ...
                        '  DeltaTheta_1   hyper-time interval between two consecutive grid points in theta_1-direction \n' ...
                        '  DeltaTheta_2   hyper-time interval between two consecutive grid points in theta_2-direction \n' ...
                        '  theta_1_i      hyper-time theta_1 at theta_1_i = i * DeltaTheta_1 \n' ...
                        '  theta_2_j      hyper-time theta_2 at theta_2_j = j * DeltaTheta_2 \n' ...
                        '  z              state space vector of the system \n'];

    help_struct.mandatory = [];

    help_struct.optional.n_int_1.value        = 'positive integer >= 2 \n e.g.: 25, 50, 100, ... \n Default: 50';
    help_struct.optional.n_int_1.text         = ['Number of hyper-time intervals DeltaTheta_1 into which the hyper-time period 2*pi is divided in theta_1-direction \n (2*pi = n_int_1 * DeltaTheta_1). \n' ...
                                                 'The number of grid points used to discretise the theta_1 interval [0, 2*pi] equals \n n_int_1 + 1.']; % \n' ...
                                                 % 'Note: ''n_int_1'' must be greater than or equal to (approx_order_1 + 1) or numel(points_1) (depending on whether ''approx_order_1'' or ''points_1'' is given, see below).'];

    help_struct.optional.n_int_2.value        = 'positive integer >= 2 \n e.g.: 25, 50, 100, ... \n Default: 50';
    help_struct.optional.n_int_2.text         = ['Number of hyper-time intervals DeltaTheta_2 into which a hyper-time period 2*pi is divided in theta_2-direction \n (2*pi = n_int_2 * DeltaTheta_2). \n' ...
                                                 'The number of grid points used to discretise the theta_2 interval [0, 2*pi] equals \n n_int_2 + 1.']; % \n' ...
                                                 % 'Note: ''n_int_2'' must be greater than or equal to (approx_order_2 + 1) or numel(points_2) (depending on whether ''approx_order_2'' or ''points_2'' is given, see below).'];
    
    help_struct.optional.scheme_1.value       = '''central'', ''forward'' or \n ''backward'' \n Default: ''central''';
    help_struct.optional.scheme_1.text        = ['The scheme refers to the discretisation scheme used to approximate the derivation dz(theta_1_i,theta_2_j)/dtheta_1. \n' ...
                                                 '''central'': The grid points used are symmetrically distributed around theta_1_i (theta_2_j = const.). \n' ...
                                                 '''forward'': Only grid points at theta_1 >= theta_1_i are used (theta_2_j = const.). \n' ...
                                                 '''backward'': Only grid points at theta_1 <= theta_1_i are used (theta_2_j = const.). \n' ...
                                                 'Note: The property ''points_1'' is not allowed when specifying ''scheme_1''.'];

    help_struct.optional.scheme_2.value       = '''central'', ''forward'' or \n ''backward'' \n Default: ''central''';
    help_struct.optional.scheme_2.text        = ['The scheme refers to the discretisation scheme used to approximate the derivation dz(theta_1_i,theta_2_j)/dtheta_2. \n' ...
                                                 '''central'': The grid points used are symmetrically distributed around theta_2_j (theta_1_i = const.). \n' ...
                                                 '''forward'': Only grid points at theta_2 >= theta_2_j are used (theta_1_i = const.). \n' ...
                                                 '''backward'': Only grid points at theta_2 <= theta_2_j are used (theta_1_i = const.). \n' ...
                                                 'Note: The property ''points_2'' is not allowed when specifying ''scheme_2''.'];

    help_struct.optional.approx_order_1.value = 'positive integer \n e.g.: 1, 2, 3, 4, ... \n Default: 6';
    help_struct.optional.approx_order_1.text  = ['approx_order_1 describes the order of approximation of dz(theta_1_i,theta_2_j)/dtheta_1. This means that the remainding error of the approximation is proportional to (DeltaTheta_1)^(approx_order_1). \n' ...
                                                 'Note: When scheme_1 = ''central'', ''approx_order_1'' must be an even positive integer. Moreover, the property ''points_1'' is not allowed when specifying ''approx_order_1''.']; % ' ...
                                                 % 'and ''approx_order_1'' must not be greater than (n_int_1 - 1).'];

    help_struct.optional.approx_order_2.value = 'positive integer \n e.g.: 1, 2, 3, 4, ... \n Default: 6';
    help_struct.optional.approx_order_2.text  = ['approx_order_2 describes the order of approximation of dz(theta_1_i,theta_2_j)/dtheta_2. This means that the remainding error of the approximation is proportional to (DeltaTheta_2)^(approx_order_2). \n' ...
                                                 'Note: When scheme_2 = ''central'', ''approx_order_2'' must be an even positive integer. Moreover, the property ''points_2'' is not allowed when specifying ''approx_order_2''.']; % ' ...
                                                 % 'and ''approx_order_2'' must not be greater than (n_int_2 - 1).'];

    help_struct.optional.points_1.value       = 'integer vector\n e.g.: [-2,-1,0,1] \n  Default: [-3,-2,-1,0,1,2,3]';   % \n \n p_1 = numel(points_1)
    help_struct.optional.points_1.text        = ['The vector ''points_1'' specifies the local grid points in theta_1-direction which are used to approximate dz(theta_1_i,theta_2_j)/dtheta_1. \n' ...
                                                 'E.g. when ''points_1'' is set to [-2,-1,0,1], dz(theta_1_i,theta_2_j)/dtheta_1 is approximated by the state space vectors z at the grid points (i-2,j), (i-1,j), (i,j) and (i+1,j). \n' ...
                                                 'Note: All elements of ''points_1'' must be unique. ' ... % and p_1 must not be greater than n_int_1. 
                                                 'Moreover, the properties ''scheme_1'' and ''approx_order_1'' are not allowed when specifying ''points_1''.'];

    help_struct.optional.points_2.value       = 'integer vector\n e.g.: [-2,-1,0,1] \n  Default: [-3,-2,-1,0,1,2,3]';   %  \n \n p_2 = numel(points_2)
    help_struct.optional.points_2.text        = ['The vector ''points_2'' specifies the local grid points in theta_2-direction which are used to approximate dz(theta_1_i,theta_2_j)/dtheta_2. \n' ...
                                                 'E.g. when ''points_2'' is set to [-2,-1,0,1], dz(theta_1_i,theta_2_j)/dtheta_2 is approximated by the state space vectors z at the grid points (i,j-2), (i,j-1), (i,j) and (i,j+1). \n' ...
                                                 'Note: All elements of ''points_2'' must be unique. ' ... % and p_2 must not be greater than n_int_2. 
                                                 'Moreover, the properties ''scheme_2'' and ''approx_order_2'' are not allowed when specifying ''points_2''.'];

end