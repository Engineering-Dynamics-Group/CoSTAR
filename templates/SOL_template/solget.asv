%% Function solget returns a solution at a specific point in the diagram
% necessary input:
% @obj:                 Object of Solution class
% @DYN:                 Object of DynamicalSystem class
% @options:             struct contain options for calculating solution
 

% solplot
% 'yaxis':  FCN_handle @(z) z(1)
% 'xaxis':
% 'zaxis': 

% contplot
% 'yaxis':  FCN_handle, 'all','euclidean','max','min'

% 'figure'      h

function [s,mu,varargout] = solget(obj,DYN,options)      
    
    %% Check the options structure: !!! BE CAREFULE - FUNCTION MAY CHANGE OPTIONS STRUCTURE AND SOLUTION OBJECT
    options = obj.solget_gatekeeper(DYN,options);
    % --> Any case other than options.space = 'none': s_xxx is alloquated,
    %     if needed. options.resolution is either set to the given value,
    %     default or size(s_xxx). If resolution is not compativle to
    %     size(s_xxx), s_xxx is deleted and - thus - newly computed. 

    options = obj.solget_up_index(DYN,options);     %Updates options.index: options.mu (if present) is replaced by options.index in this function
    options = obj.solget_allocate(DYN,options);     %Ensures proper alloquation of the propoerties s_xxx (time, torus, frequency) of Solution class object

    %% Get the solutions and do the calculations (if necessary)

    switch options.space


        case 'solution'
            %This method can return any data type
            %HOWEVER: If its returns something else than an array:
            %options.eval must be set to 'all' together with an according
            %warning
            [s,mu,options]          = obj.evalsol_solution(DYN,options);
            
        case 'time'

            %This method must return array structures
            [s,mu,varargout{1,1}]   = obj.evalsol_time(DYN,options);

            %The solutions are stored here and not in the function itself, 
            %since evalsol_frequency or evalsol_torus might internally call
            %evalsol_time. If this is the case, no properties s_time or
            %time are alloquated, since the 'space' is not 'time'

            %Store in the solution properties for later use
            obj.s_time(:,:,options.index) = s;
            obj.time(:,1,options.index) = varargout{1,1};
   
        case 'torus'

            %This method must return array structures
            [s,mu,varargout{1,1}]   = obj.evalsol_torus(DYN,options);

            %Store in the solution properties for later use
            obj.s_torus(:,:,options.index) = s;
            obj.torus_coord(:,1,options.index) = varargout{1,1};
            

        case 'frequency'
            
            %This method must return array structures: It operates on
            %time series.
            [s,mu,varargout{1,1}]   = obj.evalsol_frequency(DYN,options);

            %Store in the solution properties for later use
            obj.s_frequency(:,:,options.index) = s;
            obj.frequency(:,1,options.index) = varargout{1,1};
            
            

    end

    % Apply the requested function to the data
    if strcmpi(class(options.eval),'function_handle')

        s = options.fcn_handle(s);

    elseif ischar(options.eval)

        switch options.eval

            case 'euclidean'

                s = vecnorm(s,2,2);

            case 'all'
                %Nothing is done here - just for readibility
        end

    end





end